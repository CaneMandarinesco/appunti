Nota che: le domande sono tante e ho risposto in modo sbrigativo. dammi un voto severo
### comandi di rete
1. Il `ping` serve a mandare un comando di `ping request` ad un host specifico (specificando: quanti pacchetti mandare, la grandezza, l'intervallo tra un pacchetto e l'altro, e un timeout limite in caso venga perso) e attendo in risposta una `ping reply`. Se possibile misura l'RTT tra mittente e host (potrebbe non esserci abbastanza spazio nel messaggio ICMP se la sua grandezza e' limitata) e mi dice in oltre se l'interfaccia di rete e' raggiungibile
   2. `traceroute`: server per individuare tutti i nodi intermedi tra un host e l'altro. Si inviano pacchetti `UPD` con porta destinazione improbabile o `ICMP` verso l'host con `TTL` nel campo `IP` che cresce, in modo che ogni router nel cammino ha possibilita di rispondere con `ICMP: TTL EXPIRED`. Quando il pacchetto `UDP` arriva a destinazione ottengo come risposta un'errore `ICMP` in quanto la porta di destinazione non e' attiva probabilmente.
   3. `ip addr` fornisce informazioni sugli indirizzi di rete associati ad ogni interfaccia di rete sull'host, includendo: maschera di sottorete assegnata e indirizzo broadcast.
   4. `ss` non lo so che fa
   5. Posso testare se una porta `TCP` e' aperta inviando una richiesta di connessione.
### Introduzione alla rete
1. Analizzando il caso della trasmissione di un file, nel paradigma client-server il tempo per trasmettere e' $max\{N \frac {F}{u_{s}}, F/d_{min}\}$ ossia il massimo tempo che impiega il server a trasmettere un file di $F$ bit a $N$ client con $u_s$ velocita di upload e la velocita massima che impiega un client per scaricare tutto $F$. Dunque il collo di bottiglia e' causato dal client, considerando che, generalmente un server e' potente! In $p2p$ invece il tempo di trasmissione massimo e': $max\{ \frac{F}{u_{s}}, \frac{F}{d_{min}}, \frac {NF}{u_{s} + \sum u_{d}}\}$ ossia il tempo che impiega il detentore del file originale a trasmettere il file a qualcuno, il tempo piu grande che qualcuno impiega a scaricarlo e il tempo che impiega tutta la rete p2p a trasmettere il file in rete. Dunque e' piu vantaggioso p2p nel caso in cui ho tanti peer disposti a condividere e ad alta velocita. Altre parole chiave: `ranking`, `tit-for-tat`, `optimistically unchocked`, `chunk`, `seeder`, `tracker`.
2. Per latenza di un'applicazione e' rappresentato dall'`RTT`, ossia il round trip time: il tempo che impiega un piccolo pacchetto ad andare verso destinazione e a tornare all'origine. Descrive la latenza che ho tra il tempo in cui invio una richiesta e quando ottengo una risposta. L'`RTT` e' influenzato principalmente dai ritardi di accodamento, di coda, propagazione e trasmissione che se alti portano alla congestione. Una rete congestionata avra router con buffer pieni e dunque pacchetti persi o che subiscono ritardi alti di accodamento! Dunque `RTT` molto alto. L'`RTT` aumenta esponenzialmente quando la banda di rete quasi tutta saturata
3. Il troughput e' quanto un'host riesce a immettere in rete, mentre la banda nominale indica la capienza effettiva di quel collegamento. Un host potrebbe avere un trooughtput inferiore alla banda nominale, oppure la puo' saturare.
4. Gia risposto in parte al punto 2
5. DNS server per tradurre i gli `hostname` in indirizzi `IP`, a livello di rete, l'instradamente utilizza gli indirizzi e non i nomi. E' un database distribuito, organizzato gerarchicamente ed e' best effort: potrebbe non darmi la risposta migliore. Invece `DHCP` ha tutt'altra funzione: mi server per ottenere un `ip` univoco in rete attraverso `dhcp discover` `dhcp reply` `dhcp offer` `dhcp ack`. Sono sicuro di non condividere lo stesso `IP` di qualcun'altro. `DHCP` mi fornisce anche informazioni su maschera di sottorete, ip del gateway router, indirizzi mac utili, indirizzo di broadcast ecc...
### trasporto
* 1. banale
* 2. AIMD e' un protocollo per stimare correttamente la `cwnd` in modo da evitare di congesitonare la rete. La `cwnd` cresce di `1MSS` ad ogni messaggio, quando rilevo una perdita pero' `cwnd` viene dimezzata, e si ricomincia a crescere additivamente. Non e' molto conveniente dato che la `cwnd` potrebbe crescere moltissimo ma la crescita e' di solo `1MSS` a messaggio.
* 3. in Reno a seguito di 3 ack duplicati dimezzo la cwnd e vado in fast recovery, ossia reinvio subito, senza aspettare timeout il pacchetto per cui ho ricevuto i 3 ack. In caso di timeout invece imposto la `cwnd` a 0 ma cresco usando `slow start`, ossia cresco esponenzialmente in modo da arrivare piu velocemente al valore di `ssthresh`, ossia la meta rispetto al valore di `cwnd` di quando si e' verificata la perdita 
* 4. risposto in 3.
* 5. In Vegas ricordo l'RTT minimo misurato nella connessione. Se mi allontano da questo valore allora c'e' tanta congestione, dunque diminuisco la cwnd, se mi avvicino aumento la cwnd.
* 6. In tcp cubic preferisco crescere molto velocemente, ma rallentare quando mi sto per avvicinare a $W$, ossia la `cwnd` rispetto a quando si era verificata una perdita stimando il valore $K$, ossia l'istante nel futuro in cui mi avvicinero a $W$. Dunque la cwnd cresce seguendo il cubo: cresce velocissimo ma e' lenta ad arrivare a $W$ in sua prossimita

### rete
* 1: bo, un'ip statico non viene richiesto dal server `dhcp` e solitamente rimane fisso, quindi non ha un `ttl` per cui scade. Un `dhcp` dinamico indica che l'interfaccia di rete puo' spostarsi e eventualmente andare down.
* 2: Il `TTL` indica il numero di salti massimi che puo' fare un pacchetto ip. Ogni volta che il pacchetto passa per un router il valore viene decrementato e se vale 0 viene scartato in quanto: troppo vecchio. Di solito il router risponde inviando al mittente un messaggio `ICMP` di errore, quindi con categoria 3.
* 3: gia risposto prima.
* 4. Il router quando riceve un pacchetto in input deve determinare verso quale interfaccia di output deve andare. Questo meccanismo e' attuato su due piani: piano di controllo, che per ogni router nell'AS calcola in modo centralizzato (SDN) le tabelle di inoltro da installare e distribuire e il piano dei dati ossia quello che attua la tabella di inoltro grazie a processore e struttura di commutazione. Il forwarding consiste nell'inoltrare il pacchetto verso la giusta porta in modo da farlo arrivare a destinaizone!
* 5. per routing statico si intendo un routing che non cambia le tabelle di inoltro a seguito di cambiamenti nei pesi dei collegamenti, al massimo e' una procedura che viene fatta manualmente. per routing dinamico si intendo un'algoritmo che ad ogni variazione dei pesi, ricalcola le tabelle di inoltro in modo da avere sempre il percorso migliore verso una certa destinazione. I pesi degli archi possono essere per esempio: inversamente proporzionali alla larghezza di banda, proprzionali alla congestione, ma e' problematico questo metodo: possono nascere oscillazioni dannose, e cambiamenti bruschi possono viaggiare lentamente all'interno della rete se si usa un algoritmo distribuito.
* 6. NAT viene utilizzato per risolvere il problema degli `ip` limitati e per introdurre una specie di firewall che protegge la rete. Dall'esterno, tutti i servizi di rete all'intero della stessa sottorete sono accessibili usando un'unico indirizzo, ma con porte differenti. Nel gateway router e' presente una tabella di nat che indica ad ogni porta quale indirizzo ip e quale porta corrisponde veramente! Dunque per ogni pacchetto in entrata e in uscita devo modificare i dati a livello di trasporto e di rete.
* 7. non lo so fra

### livello collegamento
1. Il link di collegamento si effettuare il framing dei pacchetti e di trasmetterli sul mezzo di trasmissione e naturalmente anche di riceverli. La trasmissione a questo livello e locale, ossia non sto offrendo una connessione logica verso la destinazione ma verso l'interfaccia di rete disponibile localmente! Ci pensa `ip` a far arrivare i dati veramente a destinazione. Offre anche error detection e un protocollo distribuito di accesso al mezzo. Esempi di protocolli sono ethernet, wifi e bluetooth.
2. Bo mai sentito
3. Il `MAC` address, a differenza di ip, non e' gerarchico, ma e' teoricamente assegnato in modo univoco ad ogni interfaccia di rete. Posso volendo impostare un mac a piacimento per l'interfaccia. Server in modo che ogni interfaccia in ascolto sul mezzo trasmissivo possa riconoscersi e capire che quel frame e' per se stessa. Nota: se un'interfaccia cambia sottorete il mac rimane uguale
4. Uno switch e' un dispositivo attivo, plug and play, e invisibile alla rete che si occupa di fare flooding del frame ethernet verso tutte le interfacce e di imparare verso dove indirizzare i frame, cosi da evitare flooding. L'hub invece e' un dispositivo che ripete il segnale ebasta???? non lo so
5. CSMA/CD viene usato in ethernet dato che: alta efficienza, semplice eccc..... ma gia lo so! Il principio e' che faccio collision detection mentre trasmetto, se rilevo collisione mi interrompo, trasmetto segnale di jam e in caso di ethernet uso exponential backoff per capire in modo probabilistico se ritentare o no
6. ARP e' necessario per capire a livello di collegamento quale mac di destinazione usare, dato che a "priori" conosco solo l'indirizzo ip di destinazione. Se l'ip e' nella stessa sottorete faccio una richiesta arp con mac di broadcast per quell'ip, ottengo dunque in risposta il suo mac address e lo salvo in memoria con un certo `ttl`. Posso successivamente mandare in rete il frame con il giusto mac di destinazione.
7. In termini di gestione, la wireless lan e' soggetta a problemi di: rifrazione, ostacolo e attenuazione del segnale e a maggiori errori nei bit e maggiore latenza!!!!

Errori