Alice e Bob che vogliono comunicare, stabiliscono di comune accordo una **secret key**, questa viene usata per trasformare i messaggi in modo che quando trasmessi, siano illegibili, o quanto meno, privi di senso.

> **Nota**: questo processo e' l'`encryption`, che produce il `ciphertext`.


Quando Alice manda, e Bob riceve il `ciphertext`, usando la `sceret key` puo' decifrare il messaggio.

> **Nota**: questo processo e' la `decryption`.

Con la `cryptanalysis` si cerca di rompere la chiave, ossia di trovarla, attraverso varie tecniche:
* **exhaustive key search**: provo tutte le chiavi! Se le chiavi possibili sono poche... allora ci metto poco a testare tutte le chiavi, *dunque voglio tantissime chiavi possibili*!

Il modello descritto fin'ora e' detto **secret-key cryptography**: ossia una sola chiave condivisa da `A` e `B` e questa e' usata per criptare e decriptare.

> **Problema**: come fanno `A` e `B` a concordare la chiave, specialmente se sono **distanti**?

### chiave pubblica
La **public-key cryptography** e' stata introdotta nel 1970 da **Diffie e Hellman**. Con questo sistema e' possibile avere due chiavi:
* `public key`: usata per criptare il testo. La chiave e' conosciuta da tutti.
* `private key`: usata per decriptare il testo. Conosciuta solo da chi riceve il messaggio.

> **Nota**: `RSA` e' basato su sta rob a.


### block e stream ciphers
I sistemi di crypto sono di due tipi: `block/stream ciphers`. 

> [!note] `block ciphers`
> Il testo e' diviso in chunk di grandezza fissa, ossia `blocks`, dove un blocco e' una **stringa di bit** di lunghezza fissa (128 o 64 bit per esempio)


> [!note] `stream ciphers`
> La chiave e' usata per costruire la **keystream**, una stringa di bit di lunghezza arbitraria

### crittografia ibrida
* *crittografia public key*: e' **lenta**! dunque viene usata in contesti dove i messaggi sono piccoli.

> [!note] `hybrid cryptography`
> Con questa, si suppone che Alice abbia un messaggio **lungo** da mandare a Bob.
> Questi non hanno nemmeno una **secret key** condivisa a priori, allora Alice puo' sceglierne una e criptarla usando la chiave pubblica di Bob. Da qui, posso criptare con un sistema a **secret key**!

### integrita dei messaggi
La crittografia serve a proteggermi da un'attacante **passivo**. si assume che possa ascoltare il flusso di informazioni che passa tra `A` e `B`.

Altre volte vorremmo proteggerci da un'attacante **attivo**, in grado di prendere i dati da `A` verso `B` e di modificarli, o magari che finga di essere `A` o che li inoltri da qualche altra parte.

Dobbiamo dunque garantire che i messaggi siano integri usando il `MAC`: **Message authentication code**.

Funziona cosi, supponendo che `A` e `B` condividano una chiave segreta:
1. Alice usa la chiave segreta per creare un **tag**
2. Alice manda **messaggio e tag**
3. Bob decripta messaggio e tag con la chiave, se il tag corrisponde allora tutto ok!

Possiamo utilizzare anche un **algoritmo di signing** (che conosce solo il mittente) che firma i messaggi. Similmente al MAC, l'algoritmo produce una **signature** che dipende dal messaggio e dalla chiave, e questa viene appesa al messaggio da trasmettere.

Dall'altra parte, un **verification algorithm** (*che conoscono tutti*) prende il messaggio e la firma e restituisce **true** se la firma puo' essere considerata valida.

> **Nota**: con `MAC`, solo il destinatario (o chi possiede la chiave privata) puo' verificare l'autenticità del messaggio

> **Nota**: in contesti di gruppi di persone che vogliono fidarsi l'uno dell'altro, allora conviene usare le **firme**.

> [!note] nonrepudation
> Se firmo un messaggio, vuol dire che io l'ho prodotto e tutti lo sanno.

>[!note] certificato
> Serve a verificare l'autenticità delle chiavi pubbliche. Il certificato contiene informazioni su un utente o un sito web e sulle sue chievi pubbliche. Queste sono firmate da un'autorita centrale!

> **Nota**: per comunicare con l'ente centrale, bisogna che tutti sappiano la sua chiave pubblica.

> [!note] hashing
> Una funzione di hashing crittografica, serve ad accorciare la lunghezza di un messaggio, producendo il **message digest**. Tutti conoscono la funzione di hasing

La funzione di hasing, non dovrebbe avere collisioni!

## protocolli
> [!note] protocollo
> scambio di messaggi tra due o piu parti. La sessione di un protocollo e' costituita da uno o piu flussi di messaggi.

> [!note] identification scheme
> E' un protocollo con cui voglio provare la mia identita a qualcuno mostrandogli una password

> [!note] key distribution scheme
> Un'entita centrale distribuisce le chiavi

> [!note] key agreement
> A e B decidono una secret key comune.


> [!note] scret sharing scheme
> Un'autorita centrale fornisce chiavi segrete per sottoinsiemi di nodi.

## sicurezza
in crittografia dobbiamo considerare:
* modello di attacco
* obiettivo avversario
* livello di sicurezza

Il **modello di attacco** indica *l'informazione disponibile all'avversario*, assumendo che l'avversario conosce schema o protocollo usati (**principio di Kerckhoffs**) e la chiave pubblica.

L'**obbettivo avversario** descrive cosa vuole fare per rompere il sistema crittografico. I sistemi di crittografia corretti si assume che siano inattaccabili sotto risorse computazionali limitate.

L'avversario potrebbe non essere interessato a fare un **complete break** del sistema crittografico, ma potrebbe accontentarsi di decriptare alcune parti di testo.

Si studiano i seguenti livelli di sicurezza:
* computazionale: il sistema puo' essere rotto da un'algoritmo in un tempo non ragionevole
* sicuri teoricamente: ossia rompere il sistema vuol dire risolvere un problema computazionalmente difficile
* incondizionalmente sicuro: l'attaccante non ha risorse per rompere il sistema
* 
