* Intel® 64 and IA-32 Architectures Software Developer’s Manual (Volume 1, 2, 3)
* Intel® 3 Series Express Chipset Family Datasheet
* System V Application Binary Interface

Le prime 50 pagine sono un'introduzione interessante all'architettura di un computer. Si parla in modo breve ma esaustivo di transistor, porte logiche, architettura della CPU.
### obj dump
Serve a mostrare informazioni sui file oggetto.
```bash
objdump -d hello
```

> [!note] sezione
> E' un blocco di memoria che contiene dati o codice eseguibile.

> **Nota**: Con l'opzione `-d` mostriamo solo sezioni che contengono codice eseguibile, mentre con `-D` mostro l'assembly di tutte le sezioni.

> **Nota**: se compilo il file `c` con `-g`, allora con `objdump -S hello` posso ottenere il sorgente associato all'assembly.
> 

> **Nota**: con `-M` specifico la sintassi per interpretare l'assembly.


Ora, per capire bene assembly, solo per x86, tocca leggere 5000 pagine di manuale!

Ora vediamo com'e' fatta l'istruzione `jmp eax`, criamo un file `test.asm` e diciamo a `nasm` di assemblare con output in binario puro (no ELF):
```
nasm -f bin test.asm -o test
```

Con `hexdump test` posso vedere il compilato, per scoprire che consiste solo dei byte: `ff 66 00 e0` (dipende dalla CPU: se little endian o big endian).

> **Nota**: usando il formato bin, `nasm` scrive in `16-bit` mode. Per andare in `32-bit` mode nel sorgente scriviamo `bits 32`.

### Introduzione all'anatomia di un'istruzione x86
> **Nota**: fare riferimento al capitolo 2 del manuale di intel.

![[Pasted image 20251008230242.png]]
* `opcode` identifica una istruzione, ogni opcode e' ha un nome mnemonico.

> **Nota**: per esempio `jmp [0x1234]` genera `ff 26 34 12`, dove `ff` e' l'opcode che identifica `jmp`.

* `ModR/M` indica se l'operando e' un registro o una locazione in memoria
	* `mod`: insieme a `r/m`, costituiscono 5 bit per codificare 8 registri e 24 modalità di indirizzamento.
	* `reg/opcode`: codifica un registro oppure estende ``

Nell'esempio della jump, `26` indica il byte `ModR/M`, che viene tradotto con `disp16`, ossia indirizzamento a offset di `16-bit`.

> **Nota**: il valore `ModR/M` viene interpretato facendo riferimento alla tabella nel libro.

#### `add eax, ecx`
L'istruzione `add eax, ecx` si traduce in `66 01 c8`:
* `0x66` e' il prefisso opzionale, indica un'istruzione eseguibile solo in ambiente a 32-bit. 
* `0x01` e' l'istruzione 
* `0xc8` l'indirizzamento specificato in `ModR/M` che specifca `eax` ed `ecx`.

#### `SIB`
fa parte dell'istruzione il byte ScaleIndexBase, ossia un indirizzo calcolato in questo modo: $scale*index+base$ dove:
* $index$ e' l'offset dell'array in $base$
* $scale$ e' il fattore da applicare a $index$

#### `jmp [eax*2 + ebx]`
Genera il codice `67 ff 24 43`:
* `0x67: prefisso`
* `0xff`: istruzione
* `0x24`: ModR/M
* `0x43`: SIB (ossia `scale*index+base`)

#### `jmp [0x1234]`
genera: `ff 26 34 12`. dove `34` e `12` corrisponde all'indirizzo `0x1234` mentre `0x26` specifica `ModR/M`


#### `jmp [eax * 4 + 0x1234]`
genera: `67 ff 24 85 34 12 00 00`
* `0x67`: address-size override prefix. Ossia se per esempio un'istruzione opera a 16-bit, con `0x67` va in 32-bit! Sembra figo!
* `0xff`: opcode
* `0x24`: `ModR/M`, indica la presenza di un SIB
* `0x85`: `SIB` byte

#### `jmp [eax * 4 + eax + esi]`
Come prima, ma il byte `SIB` ora e' `0x86`, ossia ha un 1 nel primo byte  di `R/M` per fare riferimento a `esi`


#### `mov eax, 0x1234`
Genera: `66 b8 34 12 00 00`. Dove viene usato **indirizzamento immediato**, ossia i dati si trovano subito dopo l'istruzione!

`0x34 12 00 00` perche' il prefisso `0x66` potra l'istruzione a leggere valori di `32-bit`.


> [!warning] esercizio
> **provare** a leggere `2.1` nel Volume 2 e `7` in volume 1.

## capire un'istruzione (dal manuale)!
* `opcode`: indica un numero unico esadecimale assegnato ad un'istruzione. Possono esserci piu opcode per ogni istruzione, il che indica una **variante**
* `instruction`: sintassi in assembly
* `op/en`: ossia Operand/Encoding. se `D`, l'operando e' specificato in `ModR/M`
* `CPUID FEATURE FLAG`: indica se una feature deve essere abilitata per usare l'istruzione
* `Compat/Leg Mode`: molte istruzioni non hanno il campo `CPUID FEATURE FLAG` (???), che e' rimpiazzato da questo. Con questo posso vedere se l'istruzione a 64-bit puo' eseguire anche a 16 o 32 bit.
* `operation`: pseudocodice che fa capire meglio l'istruzione
* `flags affected`
* `exceptions`: errori possibili. vedere `3.1.1.13` e `3.1.1.14` vol 2.

> [!warning] esercizio
> fare riferimento a cap. 4 vol 1 sui "data Type"

> **Nota**: `jmp far [eax]` genera `67 ff 28` dove `28` codifica `[eax]`

# esaminare un file compilato
```bash
objdump -z -M intel -S -D -j .data -j .bss <object
file> | less
```

I tipi di dati in x86 sono insiemi di byte da: 1 byte, 2 byte, 4, 8 e 16 byte. 

> **Nota**: i riferimenti a questi tipi di dati devono essere allineati! Altrimenti ho bisogno di piu letture!
> *Alcune istruzioni richiedono dati allineati in memoria*.


> **Nota**: in `c`, `char` indica l'unita di memoria piu piccola indirizzabile. Non e' garantito che `char` sia `1 byte`.


Quando si lavora con i puntatori in `x86` ce ne sono due:
* `near pointer`: ossia un'offset da applicare ad un segmento
* `far pointer`: esplicito anche la parte del segmento

![[Pasted image 20251009102142.png]]


## bit fileds

```c
struct bit_field2 {
	int data1:8;
	int data2:8;
	int data3:8;
	int data4:8;
	char data5:4;
}
```

> **Nota**: if additional data members are specified after .data1, two scenarios happen: If the new data members fit within the remaining bits after .data, which are 24 bits7, then the total size of bit_field struct is still 4 bytes, or 7 Since .data1 is declared as an int, 32 bits are still allocated, but .data1 can only access 8 bits of information.32 bits.

Con `objdump`, se proviamo ad allocare la struttura `bit_field2`, noteremo che `data1,data2,data3,data4` occupano solo 32-bit (o 64, a seconda dell'architettura). 
Mentre `data5` occupa tutti i bit richiesti dal tipo `char` sul tuo computer.
## strings
> **Nota**: stringhe `x86` sono diverse da quelle in `C`.

definizione di stringa:
* `x86`: una sequenza continua di bit, byte, word o doublewords
* `C`: array di caratteri di 1 byte dove l'ultimo e' carattere di terminazione.

## analisi di codice
Con `objdump`, il primo esempio compila in sta roba:
```asm
0000000000001119 <main>:
	80483db: push ebp
	80483dc: mov ebp,esp
	80483de: sub esp,0x10
	80483e1: mov eax,ds:0x804a018
	80483e6: mov DWORD PTR [ebp-0x8],eax
	80483e9: mov DWORD PTR [ebp-0x4],0xabcdef
	80483f0: mov eax,0x0
```

Dunque possiamo dedurre che:
* `j` si trova a `rbp-0x8`
* `k` si trova a `rbp-0x4`

> **Nota**: per fare `j=i`, c'e' bisogno di usare un registro ausiliario, in questo caso `eax`.

`mov eax,0x0`, corrisponde a `return 0`;
> **Nota**: probabilmente viene fatto `rsp`
