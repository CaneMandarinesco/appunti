> [!warning] esercizio
> Lettura del capitolo 7 del volume 1, come esercizio!
> 

L'ambiente general-purpose consiste di:
* `general-purpose-register` utilizzabili in non-64-bit mode, ossia `EAX, EBX, ECX, EDX, EBP, ESI, EDI, ESP`
* `segment registers`
* `EFLAGS reg`: 32-bit per status e flag su aritmetica, ecc..
* `EIP`: Instruction Pointer

Quando siamo a 64-bit:
* `general purpose register`: sono 16
* `segment registers`
* `flag e status`: `RFLAG`
* `RIP`: Instruction pointer

### Data transfer instructions
Usate per muovere byte, word, duoblewords o quadwords tra memoria e registri, oppure tra registri e registri.

#### General data mov
Sono:
* `MOV`: non permette il trasferimento tra indirizzi di memoria! Quello lo puo' fare `MOVS` (nella categoria delle operazioni su stringhe)
* `CMOVcc`: un gurppo di istruzioni che guardano `EFLAG` prima di vare una mov 

#### Exchange instructions
Fa lo swap di uno o piu' operandi e in alcuni casi asserisce il segnale `LOCK`.

* `XCHG` server a fare lo swap di due operandi senza richiedere una locazione temporanea asserendo `LOCK` (utile per la gestione della concorrenza).

* `BSWAP` inverte l'ordine in cui compaiono i byte in una parola (utile per convertire big endian e little endian)
* `XADD`: fa la somma in un'operando di destinazione, e fa lo swap dei due operandi
* `CMPXCHG`: usato di solito con i semafori

#### stack
`PUSH, POP, PUSHA` (push all registers) per muovere nello stack!

#### conversione di tipo
* `CBW`: byte to word, viene copiato il segno in `AL` nei bit piu alti di `AX`
* `CWDE`: word to doubleword extended
* `CWD`: word to doubleword

`MOVSX`e `MOVZX` sono istruzioni che dopo la `mov` estendono il bit del segno, similmente a come fanno le istruzioni di conversione di tipo.

#### comparazione 
`cmp`: fa la sottrazione di due operandi e aggiorna le flag di conseguenza, senza modificare nessun registro e dunque senza salvare il risultato.

`neg`: fa la sottrazione rispetto a 0 di un'operando espresso in complemento a due 

#### mul e div
`MUL` (unsigned) e `IMUL` (signed) fanno la moltiplicazione. E similmente abbiamo `DIV` e `IDIV`

#### altri tipi di istruzioni...
> **Nota**: nn mi va di leggerle. Tra quest compaiono istruzioni per shift, bit scan, test instruction, ecc...

#### unconditional transfer
`JMP, CALL, RET, INT, IRET` sono istruzioni che modificano il program control, dove l'indirizzo di destinazione puo' essere nello **stesso segmento di codice**, o in un'altro.

La **jump** trasferisce il controllo ad un'istruzione di destinazione, dove l'indirizzo puo' essere relativo o assoluto.

* **assoluto**: può messo essere in un registro (dunque si comporta come un puntatore), che viene copiato in `EIP`, oppure specificato usando una modalità di indirizzamento. Se la destinazione e' vicina, allora uso l'indirizzo come offset, altrimenti viene tradotto in un segment selector (copiato nel registro `CS`) e ne viene estratto l'offset da applicare.
* **relative**: l'indirizzo e' un displacement dall'`EIP` register.

La `CALL` e `RET` permettono di implementare procedure e subroutine.
`CALL` permette a `RET` di ottenere l'indirizzo di ritorno usando lo stack.

`IRET` ritorna da un interrupt. Si comporta come `RET`, ma ripristina dallo stack lo stato di `EFLAGS`.

#### conditional transfer
L'esecuzione del salto dipende dalle status flag specificate!

Le `loop` instructions usano il registro `ECX` per tenere in memoria quante volte e' stato eseguito un frammento di codice, decrementando `ECX` di volta in volta.

`LOOPE` e `LOOPZ` testano anche le flag.

`JECXZ` (jump if ecx zero) fa il salto se `ecx` e' 0, mentre `JCXZ` testa il registro `cx`.

#### software interrupt
`INT n` porta a gestire l'interrupt `n`, ci si aspetta poi la `IRET` per riprendere l'esecuzione da dove era stata interrotta.

`INTO` solleva un'eccezione se `OF` e' impostato

`BOUND` compara un valore con un range, definito da lower bound e upper bound. Se viene superato, allora viene generata un'eccezione.

#### stringhe

`MOVS, CMPS, SCAS, LODS, STOS` permettono di fare istruzioni su strutture date enormi, come stringhe di caratteri, dove `ESI` specifica l'indirizzo sorgente della stringa, ed `EDI` ne specifica la destinazione.

Il registro `ESI` viene usato in combinazione con il segmento specificato in `DS` (eventualmente posso cambiare registro associato), mentre `EDI` usa `ES`, ma non posso cambiare registro per la segmentazione.

`MOVS` muove i dati da `ESI`, nella posizione specificata da `EDI.`

Ogni istruzione che opera su stringhe prevede di essere eseguita piu volte usando le istruzioni repeat.

> **Nota**: `ESI` ed `EDI` sono incrementati automaticamente dopo un'istruzione stringa.

e altre... da finire......!!!
