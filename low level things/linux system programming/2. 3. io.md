> **Nota**: la maggior parte dei dettagli qui sotto sono richiesti dallo standard POSIX. (Per esempio il fatto che close ritorni certi tipi di errori e' mandatorio per POSIX)
# open
```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open (const char *name, int flags);
int open (const char *name, int flags, mode_t mode);
```

```c
int fd;

fd = open("/path/to/file.txt", O_RDONLY);
if (fd == -1) /* error */ 
```

Quando apro un file devo specificare le flags: `O_RDONLY`, `O_WRONLY`, `O_RDWR`.

Inoltre posso specificare:

| flag          | desc                                                                                                        |
| ------------- | ----------------------------------------------------------------------------------------------------------- |
| `O_APPEND`    | **modalita append**, ogni write e read sara fatta dopo aver aggiornato la posizione nel file alla sua fine. |
| `O_ASYNC`     | Genera il segnale `SIGIO` quando il file e' disponibile per lettura o scrittura                             |
| `O_CLOSEXEC`  | Chiudi il file quando viene creato un nuovo processo.                                                       |
| `O_CREAT`     | Se il file non esiste crealo                                                                                |
| `O_DIRECT`    | Direct IO                                                                                                   |
| `O_DIRECTORY` | Da specificare se si vuole aprire una directory. usato da `opendir`                                         |
| `O_EXCL`      | Insieme a `O_CREAT`, fallisce se il file gia esiste! Utile per le race conditions ???                       |
| `O_LARGEFILE` | usato implicitamente su architettura a 64bit                                                                |
| `O_NOATIME`   | Non aggiornare l'ultimo accesso di un file quando voglio solo leggere.                                      |
| `O_TRUNC`     | Se il file esiste ed e' regolare, allora il file viene troncato a 0.                                        |
> **Nota:** per determinare se ho diritto di accesso ad un file basta vedere se l'uid del file coincide con l'uid del processo.

L'argomento `mode` indica i permessi nel formato unix, ad esempio `644` indica che il proprietario puo' leggere e scrivere, gli altri solo leggere.

Mode puo' essere  impostato usando anche le definizioni fornite dalla libreria.

Le due righe sono equivalenti:

```c
int fd = open(file, O_WRONLY | O_CREAT | O_TRUNC, 
			S_IWSUR | S_IRUSR | S_IWGRP | S_IRGRP | S_IROTH);
fd = open(file, O_WRONLY | O_CREAT | O_TRUNC, 0664);
```

La combinazione di flag `O_WRONLY | O_CREAT | O_TRUNC` e' molto comune, dunque esiste la procedura `creat`.

`open` e `creat` ritornano il file descriptor al successo, altrimenti `-1`

# read
```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t len);
```

Al successo, viene ritornato il numero di byte letti, altrimenti `-1`. Leggendo, la posizione sul file avanza del numero di byte letti, e la lettura comincia sempre dalla posizione corrente. 

> **Nota**: read puo' ritornare un `size_t` minore di `len`.

> **Nota**: quando `read` ritorna `0`, vuol dire che ha raggiunto `EOF`.

> [!note] read e' bloccante. EOF
>  quando viene fatta la `read` ma non ci sono caratteri da leggere e non si e' raggiunto `EOF`, *allora la chiamata si blocca in attesa che i dati siano disponibili*.

Se `read` ritorna `-1` ed ho `errno=EINTR`, allora posso provare a rifare la `read` poiche e' stata interrotta da un segnale, e non da un vero e proprio errore nella procedura.

Dunque la `read` puo' avere vari esiti:
* ritorno un valore uguale a `len`. Ho letto fino a riempire il buffer fornito.
* ritorno un valore minore rispetto a `len`, ma ho letto piu di 0 byte. Accade per esempio per via di un segnale che interrompe la read; un errore generale; non ci sono effettivamente altri dati da leggere
* ritorno `0` se ho raggiunto `EOF`. Nulla da leggere!
* la chiamata si blocca perche' non ci sono **dati disponibili**
* `-1, EINTR`: un segnale e' stato ricevuto prima di cominciare a leggere. Posso ritentare!
* `-1, EAGAIN`: la read mi informa che non ci sono dati disponibili e che di conseguenza si bloccherebbe.
* `-1` con un'altro tipo di errore: allora potrebbe essere successo qualcosa di strano e insolito.

## leggere tutti i byte correttamente
```c
size_t ret;
while(len != 0 && (ret = read(fd, buf, len)) != 0){
	if(ret == -1){
		if (errno == EINTR) continue;
		perror("read");
		break;
	}
	
	len -= ret;
	buf += ret;
}
```

Questo codice gestisce tutti gli errori da cui si puo' recuperare e legge `len` byte da mettere in `buf`.

## read non bloccante
In alcuni contesti voglio che la `read` ritorni subito se non ci sono dati disponibili da leggere. Vogliamo dunque aprire il file con la flag `O_NONBLOCK` e quando c'e' un errore (`-1`) devo controllare se e'  avvenuto l'errore `EAGAIN`:

```c
char buf[BUFSIZ];
ssize_t nr;

start:
nr = read(fd, buf, BUFSIZ);
if(nr == -1){
	if (errno == EINTR)
		goto start;
	if (errno == EAGAIN)
		/* ritenta piu tardi */
	else 
		/* error */
}
```

## size 

`size_t` e `ssize_t` sono tipi richiesti da `POSIX`. 
* `size_t` e' usato per valori da misurare in byte. Il suo massimo e' `SIZE_MAX`
* `ssize_t` e' una versione con segno di `size_t`. Il suo massimo e' `SSIZE_MAX` che di solito e' `LONG_MAX`.

se la `len` per `read` e' maggiore di `SSIZE_MAX` allora succedono cose strane, dunque conviene sempre mettere un controllo per evitare vulnerabilita e problemi strani.

```c
if(len > SSIZE_MAX)
	len = SSIZE_MAX;
```

## write
```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
```

La chiamata a write scrive fino a `count` bytes nella posizione corrente del file. Quando ho successo, viene ritornato il numero di byte scritti.

```c
unsigned long word = 1720;
size_t count;
ssize_t nr;
count = sizeof(word);
nr = write(fd, &word, count);
if (nr == -1) /* check errno */
else if (nr != count) /* probabilmente un errore, ma errno non settato */
```

A meno che non ci sia un errore, `write` *scrive sempre tutto quello che gli dai input*! A differenza di `read`, e' meno soggetta ad errori.

Quando pero' mi interfaccio con `socket` o dispositivi a caratteri e' meglio implementare la `write` con un loop (il codice e' simile a quello per `read`!) per essere sicuro che nulla sia andato perso.


> **Nota**: se 2 processi scrivono in append mode, allo stesso momento, sullo stesso file, *uno dei due potrebbe non star scrivendo veramente alla fine del file*, ma poco prima.

Questo perche' i processi devono sincronizzarsi.

> **Nota:** se la `write` si blocca, quindi con errore `EAGAIN` conviene riprovare piu tardi!

> **Nota**: se `count>SSIZE_MAX` il comportamento e' indefinito.

## comportamento di `write`
Quando `write` ritorna, vuol dire che il contenuto del buffer fornito e' stato copiato nel buffer del kernel.

> **Nota**: questo non e' garanzia che i dati siano stati scritti sul file! Questo comportamento e' preferibile dato che le operazioni di `IO` sono lente.

> **Nota**: il kernel si occupa di prendere i **buffer sporchi** e di scriverli in `IO`. (`writeback`) L'uso di questi buffer lato kernel permette di ottimizzare i tempi di lettura e scrittura.

Il problema con questo modello e' che non posso forzare la scrittura su disco, e questo e' un problema in caso il sistema crashi.

> **Nota**: potrebbe anche esserci il caso in cui il processo termina, ma la scrittura non e' stata ancora schedulata su disco!

Il kernel associa ad ogni buffer utente un `maximum buffer age` e tenta di scrivere su disco prima che il buffer sia troppo vecchio. Questo valore si trova in `/proc/sys/vm/dirty_expire_centisecs`

E' possibile forzare la scrittura su disco!
# IO sincronizzato
> **Nota**: tutti i sistemi operativi moderni usano buffer per implementare la scrittura deferred.

## `fsync` e `fdatasync`
```c
#include <unistd.h>
int fsync(int fd);
```
La chiamata si assicura che tutti i byte sporchi vengano scritti su disco! *Pero' `fsync` non controlla lo stato della cache dell'hard drive, sebbene l'hard drive riporti che la scrittura e' completata potrebbe trovarsi nella sua cache e non ancora su disco*.

> **Nota**: `fsync` e' bloccante. Porcozzio

Con `fdatasync` invece faccio il `flush` dei dati necessari per accedere correttamente al file, i metadati non necessari potrebbero dunque essere persi. In sostanza e' piu veloce rispetto a `fsync`.

`fsync` potrebbe non forzare l'aggiornamento della directory in cui si trova il file modificato. Dunque potrebbe occorrere chiamare `fsync` sul file descriptor della directory in cui si trova il file.
## `sync`
Meno ottimale, `sync` fa la sincronizzazione di tutti i buffer verso il disco ed e' bloccante, quindi al termine sono sicuro che sia stato scritto tutto.

> Non esiste tutta via un real case use per questa chiamata di sistema.

## `O_SYNC`
Con questa flag posso richiedere che tutte le azioni siano sincronizzate su disco.

 > **Nota**: `read` e' sempre sincronizzata su disco! Altrimenti potrei leggere dati non validi.
 
 Questa flag, implica un `fsync` dopo ogni `write`, ed ha come risultato dei tempi peggiori, sia lato utente che lato kernel (intesi come tempo speso in spazio utente e in spazio kernel)

  Non conviene usare questa flag! Il tempo di attesa diventa insostenibile!

## `O_DSYNC` e `O_RSYNC`

* `O_DSYNC`: solo i dati normali devono essere sincronizzati dopo una write, e non i metadati. (E' come applicare `fdatasync` dopo ogni `write)
* `O_RSYNC`: se accedere e leggere un file comporta la modifica dei metadati (es: timestamp di accesso) deve essere scritta su disco.

## Direct I/O
Con `O_DIRECT`, dico al `kernel` che voglio minimizzare la presenza del software di `IO` management: viene bypassata la page cache, le operazioni sincrone e dunque bloccanti.

*Pero' tutti i parametri che governano l'accesso al dispositivo devono essere multipli della grandezza del settore!*

## Chiudere
```c
#include <unistd.h>
int close(int fd);
```

La chiamata a `close` effettua l'`unmap` del file descriptor `fd` e dissocia il file dal processo.

> **Nota: Chiudere** un file, non vuol dire assicurarsi che il suo contenuto sia effettivamente scritto sul dispositivo!

A monte di un'operazione di `io` e' importante controllare il codice di errore:
* `EBADF`: il file descriptor non e' valido
* `EIO`: errore di basso livello

## `lseek`
```c
#include <sys/types.h>
#include <unistd.h>

off_t lseek(int fd, off_t pos, int origin);
```
Dove `origin`:
* `SEEK_CUR`
* `SEEK_END`
* `SEEK_SET`

L'errore ritornato puo' essere:
* `EBADF`
* `EINVAL`: origin non e' valido, oppure `pos` e' negativo.
* `EOVERFLOW`: questo errore avviene solo su `32-bit` arch.
* `ESPIPE`: `fd` e' un oggetto su cui non ha senso fare seek

## positional read write
Con `pread` e `pwrite` posso leggere e scrivere ad un determinato offset senza modificare la posizione nel `fd`.

## troncare i file
```c
#include <unistd.h>
#include <sys/types.h>
int ftruncate(int fd, off_t len);

int truncate(const char *path, off_t len);
```
Con queste chiamate tronco il file alla lunghezza specificata.

## multiplexed io
...

---
# Standard IO
La standard library di `C` offre `stdio`: una soluzione unica e cross-platform per leggere stream di dati.

La `stdio` non opera su `file descriptor` ma su `file pointer`. Il file pointer viene mappato su un file descriptor ed e' di tipo `FILE`. 

> **Nota**: `FILE` e' in caps perche' storicamente `IO` era implementato in `C` usando delle macro, e dunque scritto in caps lock.

## `fopen`
```c
#include <stdio.h>
FILE *fopen(const char* path, const char *mode);
```
dove `mode`:

| mode | r/w | tronca | crea if !exists |
| ---- | --- | ------ | --------------- |
| `r`  | r   | no     | no              |
| `r+` | rw  | no     | no              |
| `w`  | w   | si     | si              |
| `w+` | rw  | si     | si              |
| `a`  | w   | no     | si              |
| `a+` | rw  | no     | si              |

> **Nota**: errore se `fopen() == NULL`.

## `fdopen`
Per **convertire** da `file descriptor` a `FILE`:
```c
#include <stdio.h>
FILE *fdopen(int fd, const char *mode);
```

 Una volta fatta `fdopen`, `fd` non dovrebbe piu essere utilizzato dall'utente!
 
# `fclose, fcloseall`
```c
#include <stdio.h>
int fclose(FILE *stream);

#define _GNU_SOURCE
int fcloseall(void);
```

## `fgetc`
```c
#include <stdio.h>
int fgetc(FILE *stream);
```

Il valore ritornato e' `int` per potere rappresentare correttamente `EOF` (che rappresenta sia errore che end of file), dunque `fgetc` si usa cosi:
```c
int c;

c = fgetc(stream);
if(c==EOF)
	/* errr */
else
	printf("c=%c\n", (char)c);
```

## `ungetc, fgets`
Metti il carattere nella stream, in modo che la successiva lettura legga quel carattere
```c
#include <stdio.h>
int ungetc(int c, FILE *stream);
```

Per leggere un'**intera riga**:
```c
#include <stdio.h>
char * fgets(char *str , int size, FILE *stream);
```

Viene inserito un carattere null (`\0`) dopo l'ultimo byte letto, e la lettura si ferma dopo un `EOF`, o `\n`.
Ritorna `str` al successo, altrimenti `NULL`.

```c
char buf[LINE_MAX];
if (!fgets(buf, LINE_MAX, stream))
	/* error */
```

dove `LINE_MAX` e' in `limits.h`, dove `LINE_MAX` in linux e' un 
valore molto alto, dato che non ci sono limiti di grandezza.

`fgets` si ferma quando incontra `\n` che puo' essere sconveniente, dunque posso implementare `fgets` cosi:
```c
char *s;
int c;

s = str;
while(--n > 0 && (c = fgetc(stream)) != EOF)
	*s++;
*s = '\0';
```

e banalmente aggiungere dei delimitatori custom!

## `fread`
Per **dati binari**:
```c
#include <stdio.h>

size_t fread(void *buf, size_t size, size_t nr, FILE *stream);
```


## `fputc, fputs, fwrite`
> [!warning] 
> Legge `nr` dati di grandezza `size` e **ritorna** *il numero di dati di grandezza `size` letti*.

per scrivere un carattere o una stringa:
```c
#include <stdio.h>
int fputc(int c, FILE *stream);
int fputs(const char *str, FILE *stream);
```
* `fputc` ritorna `c` al successo altrimenti `EOF`
* `fputs`ritorna `str` al successo altrimenti `EOF`

per scrivere **dati binari**:
```c
#include <stdio.h>
size_t fwrite(void *buf, size_t size, size_t nr, FILE *stream);
```
> **nota**: come prima, ritorna il numero di oggetti letti.

## `fseek, fsetpos`
```c
#include <stdio.h>
int fseek(FILE *stream, long offset, int whence);
int fsetpos(FILE &stream, fpos_t *pos);
```
dove `whence` e' `SEEK_SET, SEEK_CUR, SEEK_END`. Ritorna `0` oppure `EOF`. Con `ungetc` ripristino la posizione.

`fsetpos` funziona come `fseek` con `SEEK_SET` di default ed esiste come supporto ad alcune architetture. In Linux di solito non viene usata questa procedura.

## `rewind, ftell, fgetpos`
Per **riavvolgere** la posizione e ottenere la **posizione corrente**:
```c
#include <stdio.h>
void rewind(FILE *stream);

long ftell(FILE *stream); 
int fgetpos(FILE *stream, fpos_t *pos);
```

## `fflush`
Per eseguire il `flush` del buffer:
```c
#include <stdio.h>

int fflush(FILE *stream);
```
* con `stream=NULL`: tutti i file del processo sono `flushati`.
* scrive il buffer utente in `libc` nel  buffer `kernel`. Ossia fare una serie di `fputs` e dopo `fflush` e' come fare un'unica `write`.
* per essere sicuri che i dati siano scritti nel device: `fsync`

> [!note] buffer utente in `libc`
> Usare `stdio` comporta l'uso di un buffer messo a disposizione dalla libreria `c` che risiede in **spazio utente**. Ogni procedura che chiamo risiede in spazio utente, e non faccio chiamate di sistema. Le uniche chiamate sono quelle necessarie a scrivere e a leggere

## `ferror, feof`
Dato che le procedure ritornano `EOF` in caso di errore e di effettivo `EOF`, con `ferror` possiamo testare per un errore sulla stream, mentre con `feof` testo per `EOF`.
```c
#include <stdio.h>
int ferror(FILE *stream);
int feof(FILE *stream);
```

`clearerr(stream)` pulisce lo stato di `EOF` e di errore per `stream`. 

Si usano in questo modo:
```c
if (ferror(f))
	/* error */
if (feof(f))
	/* eof */
```

## `fileno`
per ottenere il file descriptor dalla stream.
```c
#include <stdio.h>
int fileno(FILE *stream);
```

## controllare il buffering: `setvbuf`
tre implementazioni per il buffering:
* `unbuffered`: in antitesi con quello a cui serve la `stdlib`, ossia minimizzare le chiamate al kernel.
* `line-buffered`: ad ogni `\n`, il buffer viene inviato al kernel. Usato di default!
* `block-buffered`: ad ogni blocco, ideale per i file ed usato di default con questi.

> **Nota**: in `stdio` ci si riferisce a `block buffering` con il termine `full buffering`.

```c
#include <stdio.h>
int setvbuf(FILE *stream, char *buf, int mode, size_t size);
```
Con `mode`: `_IONBF, _IOLBF, _IOFBF`. Con `buf` specifico il buffer da utilizzare.

> **Nota**: `setvbuf` va chiamata dopo aver aperto la stream.

Il seguente codice presenta un **bug**:
```c
#include <stdio.h>
int main(void){
	char buf[BUFSIZ];
	setvbuf(stdout, buf, _IOFBF, BUFSIZ);
	printf("Arrr!\n");
	return 0;
}
```
**bisogna chiudere la stream**!

## Thread safety
Le operazioni della `stdio` sono generalmente `thread-safe` in quanto implementano internamente meccanismi di `lock`.

Per implementare manualmente il `lock` dei `FILE`:
```c
#include <stdio.h>
void flockfile (FILE *stream);
void funlockfile (FILE *stream);
int ftrylockfile (FILE *stream);
```
* `lock`: aspetta che la stream non sia piu `locked`
* `unlock`: decrementa il `lock`
* `trylock`: versione **non bloccante**.

> [!note] `unlocked`
> Delle funzioni nella `stdio` ne esiste una versione `unlocked`!

## Critiche alla `stdio`
* `fgets`: occasionalmente inadeguata
* `gets`: orrenda ed evirata dallo standard, infatti il sorgente dice: `warning: gets() is very unsafe; consider using fgets()
* doppio buffering, e doppia copia.

> **Nota**: una possibile soluzione al doppio buffering, potrebbe essere far ritornare dalla libreria un puntatore al suo buffer.

Conviene usare `stdio` se:
* senza, faresti molte chiamate di sistema
* voglio performance e operazioni di `io` che avvengono a blocchi. (???)
* faccio a accesso a pattern di dati (singoli caratteri o righe).
* preferisco usare `stdio` alle chiamate di sistema.

