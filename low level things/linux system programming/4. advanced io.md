# Multiplexed IO (cap. 2)
Problema: la chiamata `read` e' bloccante, e potrebbe essere blocata per molto tempo. Per esempio potrebbero non esserci dati disponibili, e nel caso di una `pipe` questo comportaamento dipende da un'altro processo.

Con il `multiplexed io` agisco in questo modo per evitare il problema e di bloccare il processo sprecando CPU:
1. Avvisami quando uno dei miei file descriptor e' disponibile
2. **Dormi** finch uno o pi√π fd sono pronti
3. Vengo svegliato da `IO`
4. Gestisci i file
5. vai a nanna
## `select`
```c
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

int select(int n,
		   fd_set *readfds,
		   fd_set *writefds,
		   fd_set *exceptfds,
		   struct timeval *timeout);
```
Blocca finche i file forniti non sono pronti per `IO` o finche non scade il `timeout`.

per creare un `fd_set`:
```c
fd_set writefds;
FD_ZERO(&writefds);
FD_SET(fd, &writefds); /* aggiungi */
FD_CLR(fd, &writefds); /* rimuovi */
```

# advanced IO

> [!note] `scatter/gather io`
> Metodo con cui l'input e output di una singola syscall accede ad un vettore di buffer

Permette:
* Natural Handling
* Efficienza
* Performance
* Atomicita

## `readv()` e `writev()`

```c
#include <sys/uio.h>
ssize_t readv(int fd, 
			  const struct iovec *iov,
			  int count);
ssize_t writev(int fd,
			  const struct iovec *iov,
			  int count);
			  
struct iovec {
	void *iov_base;
	size_t iov_len;
}
```

Ogni `struct iovec` e' un segmento, ed un insieme di segmenti e' un vettore.

Al successo e' ritornato il numero di `byte` scritti o letti!

Esempio con `writev`: 
```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <sys/uio.h>

int main()
{
	struct iovec iov[3];
	ssize_t nr;
	int fd, i;
	
	char *buf[] = {
		"bla bla bla, ble ble ble\n",
		"this should be a very\n",
		"long text. I love deathcore music\n"
	};
	
	fd = open("buccaneer.txt", O_WRONLY | O_CREAT | O_TRUNC);
	if(fd == -1) {
		perror("open");
		return 1;
	}
	
	for(i=0; i<3; i++) {
		iov[i].iov_base = buf[i];
		iov[i].iov_len = strlen(buf[i]);
	}
	
	nr = writev(fd, iov, 3);
	if (nr == -1) {
		perror("writev");
		return -1;
	}
	
	if (close(fd)) {
		perror("close");
		return 1;
	}
}
```

Esempio con `readv`:
```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <sys/uio.h>

int main()
{
	char foo[48], bar[51], baz[49];
	struct iovec iov[3];
	ssize_t nr;
	int fd, i;
	
	fd = open(...);
	
	iov[0].iov_base = foo;
	iov[0].iov_len = sizeof(foo);
	iov[1].iov_base = bar;
	iov[1].iov_len = sizeof(bar);
	iov[2].iov_base = baz;
	iov[2].iov_len = sizeof(baz);
	
	nr = reav(fd, iov, 3);
	if(nr == -1) ...
	
	for (int i = 0; i < 3; i++){
		printf("%d: %s", i, (char *) iov[i].iov_base);
	}
	
	if(close(fd)) ... ;
	return 0;
}
```

> [!note] implementazione
> `writev` e `readv` sono delle vere e proprie syscall. Dunque un'implementazione lato utente di `writev` e `readv`migliore non esiste!


## Epoll
...

## Memory mapping
Alternativa all'IO classico. Mappo direttamente in memoria il file.
```c
#include <sys/mman.h>

void * mmap*(void *addr,
			 size_t len,
			 int prot,
			 int flags,
			 int fd,
			 off_t offset);
```

* `addr`: **suggerimento** al kernel di dove dovrebbe mettere i dati in memoria. Di solito si passa 0.
* `prot`: `PROT_READ, PROT_WRITE, PROT_EXEC`.
* `flags`
	* `MAP_FIXED`: obbliga la mappatura all'indirizzo `addr`. Se il mapping fa overlapping con un'altro mapping, quest'ultimo viene scartato
	* `MAP_PRIVATE`: *The file is mapped copy-on-write and any changes made in memory by this process are not reflected in the actual file, or in the mappings of other processes.*
	* `MAP_SHARED`: scrivere nella mappatura di memoria, **equivale a scrivere nel file.** *Tutti i processi vedono i cambiamenti degli altri*.

> **Nota**: mappare un file vuol dire incrementarne il **reference count**.