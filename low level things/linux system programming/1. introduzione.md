> [!note] API
> *Interfaccia con il quale un software comunica con un'altro a livello di sorgente*. Fornisce di solito un insieme di funzioni da usare. La API definisce solo l'interfaccia. Implementarla e' un percorso a parte.


> [!note] ABI
> *Definisce l'interfaccia binaria tra due o più software su una determinata architettura*. Garantisce che se un sistema supporta una determina interfaccia `ABI` detta $X$, allora tutti i file oggetto (binari, eseguibili e non) con interfaccia $X$ funzionano su quel sistema.

ABI si occupa di definire:
* calling convention
* byte ordering
* uso dei registri
* system call invocation
* linking
* ...

# File e Filesystem

## regular files
Un **regular file** contiene byte di dati, organizzati in un **array lineare** detto **byte stream**: non e' richiesto alcun tipo di formattazione, o una particolare struttura per i file.

Le operazioni di lettura e scrittura iniziano da un `file position`, o `file offset`.

> **Nota**: posso scrivere oltre la fine del file.

> **Nota**: non posso estendere il contenuto del file scrivendo in mezzo.

La grandezza di un file e' detta **length** e si misura in byte, questa misura puo' essere **troncata** (ristretto o allargato in grandezza)

> **Nota**: lo stesso file puo' essere aperto piu di una volta da piu processi, condividendone il file descriptor.

L'utente fa riferimento ai file tramite il `filename`, ma nel file system questi sono identificati da un `inode`, ognuno ha un un `ino`(inode-number) associato, unico in tutto il file system.

Nel file system, la directory si comporta come mappatura da `filename` ad `inode`, dove ogni entry e un `link`.

Dato un path,  per ottenere l'inode, il sistema operativo deve:
* navigare tutte le `dentry` (**directory resolution**): ossia dalla radice, ottenere l'inode che descrive la cartella successiva.
* Una volta arrivato alla directory piu bassa per il percorso fornito, ottengo l'inode del file.

 > [!note] hard link
 > Quando piu filename sono mappati allo stesso inode. Se elimino un certo `filename`, allora i dati corrispondenti a quell'inode sono eliminati se e solo se non ci sono piu'.
 
> **Nota**: ogni inode nei metadati ha un `link count`.

> [!note] symbolic link
> Ossia un filename che punta ad un inode. Questo inode contiene al suo interno il filename a cui punta.

## special files
Sono **oggetti del kernel** rappresentati come file:
* device a blocchi
* device a caratteri
* named pipes
* socket

Le **named pipes** (ossia `FIFO`) sono usate per la `IPC`. Rappresentano un canale di comunicazione tra processi utilizzando un file descriptor. Accedo alla pipe usando un `FIFO special file`.

## File system e namespaces
Unix offre un namespace unificato: tutti i file system sono montati dentro un namespace unico.

> [!nota] filesystem
> collezione di file e directory secondo una gerarchia. Possono essere montati o smontati dal namespace.

> **Nota**: linux supporta file system virtuali e su rete.

Nei device a blocchi,  l'unita più piccola indirizzabile e' il **settore** di solito di 512 byte. Quando leggo da un device a blocchi, devo leggere almeno 1 settore, per intero.

Analogamente, nel filesystem l'unita piu piccola indirizzabile e' il **blocco**. Accedo facendo riferimenti a potenze di due dell'unita che usa il settore fisicamente.

> **Nota**: i blocchi in linux devono essere piu piccoli delle pagine, e allo stesso tempo piu grandi dei settori.

# Processi
I processi all'inizio sono codice eseguibile: *pure codice macchina salvato in memoria con una certa struttura*. Il formato piu comune e' `ELF` (Executable and Linkable Format).

Il formato dell'eseguibile contiene: metadata e sezioni di codice e dati. Le sezioni sono chunk lineari di codice che vengono caricati linearmente in memoria, dove byte che risiedono nella stessa sezione, in memoria avranno tra loro gli stessi permessi di accesso.

Le sezioni piu' importanti sono:
* `text`: codice eseguibile e read-only.
* `data`: dati inizializzati, ossia variabili `C` con valori definiti. Qui posso sia leggere che scrivere
* `bss`: dati non inizializzati. Ossia dati che quando caricati devono essere messi a 0 (come dice lo standard `C`)

I processi sono costituiti di 1 o piu' **thread di esecuzione** (semplicemente **threads**.

> [!note] thread
> Un thread e' l'astrazione dell'esecuzione del codice ed e' responsabile dello stato di esecuzione del processo. E' fatto di:
> * `stack`
> * stato del processore
> * instruction pointer corrente
> * memoria virtuale: di proprieta del processo e condivisa tra i suoi thread.

> **Nota:** Nel kernel, i thread sono processi normali che condividono risorse tra loro (es: memoria e file aperti). 

> **Nota**: Lato utente `pthreads` implementa la gestione dei thread.

> **Nota**: la maggior parte dei processi sono **single threaded**.

## Utenti e gruppi
Ogni utente ha un `UID` ed ogni processo ha esattamente un `uid`, che identifica l'utente che esegue il programma.

> [!note] `etc/passwd` 
> Gli utenti in linux si identificano con gli `usernames` ed i loro `uids` sono `/etc/passwd`.

> [!note] `uid=0`
> E' associato all'utente **root**.

