# Indirect addressing
Il valore passato e' un **puntatore a una variabile**. In caso si vuole usare il contenuto di un registro come puntatore si scrive `[ebx]` per esempio.

> **Nota**: i registri 16-bit e 8-bit non possono essere usati per indirect addressing.

# uso di sottoprogrammi
Nell'esempio mostrato viene messo in `ecx` l'indirizzo a cui ritornare dopo aver eseguito `get_init`. Questo paradigma e' scomodo dato che doppiamo calcolare con precisione i byte che mi separano da `$` (indirizzo corrente) all'istruzione successiva.

## stack
Le cpu implementano la struttura dello stack nativamente, ossia una `LIFO`.

> **Nota**: `SS` indica il segmento che contiene lo stack

> **Nota**: `ESP` indica l'indirizzo in cima nello stack, ossia gli elementi da togliere

> **Nota**: `push` inserisce una **double word** (4 byte) nello stack. sottrae dunque 4 a `ESP`, e immagazzina il valore in `[ESP]`.

## Calling convention
*Definisce il modo in cui trasferisco i parametri e chiamo le procedure di un determinato linguaggio.*

Per esempio in `C`, i parametri di un programma sono messi nello stack, prima della `call`. Se il parametro e' un valore da modificare, allora deve esserne passato il puntatore e se il parametro e' piu piccolo di `double word`, deve essere esteso.

Il sottoprogramma non fa il `pop` degli argomenti passati:
* se il sottoprogramma fa `pop` ottiene l'indirizzo di ritorno, e non gli argomenti! (**Nota**: prima faccio `push` degli argomenti, poi `call` mette `EIP` nello stack)
* spesso gli argomenti sono usati in vari punti del programma e non e' conveniente tenerli nei registri per tutta la durata del sottoprogramma.

> **Nota**: accedo ai parametri per **indirect addressing**.

Ora, per accedere ai dati non posso usare `ESP` come riferimento: il sottoprogramma potrebbe modificarne il valore! *Dunque si usa `EBP`, questo registro punta sempre alla base dello stack* che e' sempre fisso per tutta la durata del sottoprograma.

> **Nota**: secondo la calling convention di `C`, il chiamante quando riottiene il controllo del programma deve togliere i parametri dallo stack.

> **Nota**: `C` permette alle funzioni di avere un numero variabile di argomenti, per questo motivo e' il chiamante a togliere i parametri dallo stack.

Lo stack e' utile per mantenere **variabili locali**, fondamentale per sottoprogrammi ricorsivi. Inoltre usare lo stack e' piu efficiente in termini di memoria, altrimenti dovrei richiederla altrove nello spazio degli indirizzi del programma.

> **Nota**: le variabili locali si trovano subito dopo `EBP`

> [!note] `enter` e `leave`
> Prende due operandi e fanno il setup dello stack. il primo argomento di enter e' il numero di byte usati dalle variabili locali. Non sono mai utilizzate in quanto piu lente rispetto alle istruzioni piu semplici viste fino ad ora.


## multi-modulo
Un programma multi-modulo consiste di piu file oggetto che devono essere linkati per risolvere correttamente gli indirizzi.

> [!note] `exetern`
> In assembly, chiarisco che una label e' definita esternamente al sorgente.


> [!note] `global`
> In assembly, quando definisco una `label` come `global`, vuol dire che puo' essere usata per risolvere i nomi di altri moduli.
## C e assembly
`C` assume che una subroutine mantenga i valori dei registri `EBX, ESI, EDI, EBP, CS, DS, SS, ES`. 

> **Nota**: se questi registri cambiano valore, devono essere **ripristinati**.

`EBX, ESI, EDI` non devono essere modificati: sono usati per le *register variables* (ossia variabili immagazzinate direttamente in registri, e non in locazioni di memoria)

> [!note] `_`
> La maggior parte dei compilatori `C` inseriesci `_`all'inizio dei nomi di funzione e delle variabili globali e statiche

> [!note] reverse order
> Gli argomenti della funzione vanno messi nell'ordine opposto a quelli in cui compaiono nella firma.

Questo, permette di implementare le funzioni con numero variabile di parametri, per esempi nella `printf` sono sempre sicuro che la stringa da formattare si trovi ad `[EBP+8]`

> [!note] `lea` Load Effective Address
> `lea` carica in un registro un'indirizzo di memoria calcolato da un'espresisone. Es `lea eax, [ebx+4]` carica in `eax` il valore `ebx+4`, tutto questo senza mai accedere alla ram.
> *Puo' essere usata per calcolare l'indirizzo che dovrebbe usare un sottoprogramma per accedere ad una variabile locale.*

> [!note] ritornare valori
> Il ritorno va messo (ed eventualmente esteso) in `EAX`.
> Valori a 64 bit vanno in `EDX:EAX`, e i float in `ST0`.

Per indicare a `gcc` di usare la standard convention:
```c
void f(int) __attribute__((cdecl));
```

se voglio usare la `standard call` convention al posto di `cdecl` scrivo `stdcall`: questa richiede alla subruotine di rimuovere i parametri dallo stack e puo' essere usata solo con funzioni che prendono un numero fisso di parametri.

con `regparm` posso dire a `gcc` di usare i registri per passare fino a 3 interi alla funzione invece di usare lo stack (usato come forma di ottimizzazione)