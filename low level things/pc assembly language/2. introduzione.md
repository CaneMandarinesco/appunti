> [!nota] nibble
> Un nibble e' costituito da 4 bit!
# Computer Organization
## Real Mode
In real mode, la memoria e' limitata ad `1MB`, ossia $2^{20}$ bytes. Per indirizzare `1MB` servono quindi `20` bit, ma l'`8086` aveva solo registri a `16 bit`.

Si utilizzava questo meccanismo per ovviare al problema, prendo 2 registri a `16-bit`:
* il primo e' il `selector`, e si trova in un segment register.
* il secondo e' l'`offset`.

Si ottiene l'indirizzo fisico a 32 bit da indirizzare in questo modo:
$$
16 \times \text{selector} + \text{offset}
$$

> **Nota**: moltiplicare per 16, equivale ad aggiungere uno zero a destra in notazione esadecimale.

Questo meccanismo implementa la segmentazione in `8086`, ma ha i seguenti **svantaggi**:
* un singolo selector, indirizza fino a `64K` di memoria. E se il mio programma ha bisogno di più memoria? Allora il programma deve essere diviso in sezioni, grandi al piu `64K` e all'occorrenza devo cambiare sezione!
* Per come e' implementato, facendo riferimento alla formula, *ci sono piu coppie di selector e offset che mi danno lo stesso indirizzo fisico*.

## Protected Mode a 16-bit
Nel `80286`, quando entra in protected mode, cambia completamente il modo con cui vengono interpretati i **selector** values.

Il selector viene usato per accedere ad un **indice** nella **descriptor table**. Viene utilizzata una tecnica chiamata **virtual memory**:
* voglio tenere in memoria `ram` solo testo e dati attualmente in uso
* voglio tenere su disco i dati inutilizzati dal programma caricato

*Il vantaggio nella segmentazione in protected mode, sta nel fatto che posso spostare i segmenti tra ram e disco a piacimento.*

> **Nota**: il sistema operativo si occupa di implementare in modo trasparente questo meccanismo. 

Ogni **segmento** ha la sua **entry** nella **descriptor table**, dove le entry hanno informazioni su:
* **stato del segmento**: e' in memoria o su disco?
* **locazione in memoria**  (se caricato!) 
* **permessi di accesso**: e' per esempio read only?

> **Nota**: gli offset sono comunque di `16-bit`, dunque posso indirizzare solo `64KB`
## Protected Mode a 32-bit
Il `30386` introduce la protetta a 32-bit:
* gli offset sono di 32-bit, dunque segmenti da `4GB`
* i segmenti possono essere a loro volta divisi in pagine da `4KB`. *Il meccanismo di memoria virtuale viene implementato sulle pagine* (tengo in memoria solo le pagine del segmento che mi servono).

## Interrupts
Tal volta bisogna interrompere l'esecuzione normale della CPU per gestire degli eventi.

L'hardware del computer mette a disposizione gli **interrupt** per gestire questi eventi. Generalmente questi eventi causano il passaggio del controllo dell'esecuzione all'*interrupt handler*.

> [!note] interrupt handler
> Routine che gestiscono gli interrupt.

*Ogni interrupt ha un numero associato*, e all'inizio della memoria fisica, troviamo la tavola degli **interrupt vectors**, *dove il numero dell'interrupt e' un indice in questa tavola*.

> **Nota**: traps sono interrupt che segnalano errori.

> **Nota**: software interrupts, generati dall'istruzione interrupt.

> **Nota**: interrupt esterni, non generati dalla cpu, come le trap.

# Assembly
Un programma in assembly e' immagazzinato come testo (come un linguaggio di alto livello) ed ogni istruzione, rappresenta esattamente un'istruzione macchina, e vengono richiamata usando i loro nomi `mnemonici`.

L'assemblatore si occupa di prendere le istruzioni e convertirle in codice binario.

## operandi
Ogni istruzione ha da 0, fino a 3 operandi, che possono essere di 3 tipi:
* **registro**: l'operando e' il contenuto di un registro
* **memoria**: l'operando e' il contenuto di una locazione di memoria
* **immediati**: l'operando e' codificato all'interno dei campi liberi dell'istruzione, dunque nel segmento di codice.
* **implied**: ossia, un registro che e' assunto implicitamente.

> **Nota**: sintassi per mov. `mov dest, src`

## Direttive
E' un artefatto dell'assembler, e non riguarda istruzioni della CPU. Sono usate per impartire comandi all'assembler:
* definire costanti
* definire aree di memoria
* definire segmenti
* includere codice sorgente
* includere altri file

> **Nota**: come in `C`, un preprocessor gestisce queste direttive.

### `equ`: definire simboli
> [!note] simbolo
> E' un valore **costante** che viene usato nel programma.

definizione di un simbolo:
```asm
symbol equ value
```

### `%define`
Simile a `#define` in `C`:
```asm
%define SIZE 100
mov eax, SIZE
```

### direttive per dati
*Servono per definire spazio per la memoria*:
* posso definire lo spazio, con `RESX`, dove `X` indica la grandezza del singolo oggetto da immagazzinare.
* oppure, definire spazio e valore con cui inizializzare l'area, con `DX`, dove `X` indica la grandezza del singolo oggetto da immagazzinare.

Esempi lapalissiani:
```asm
L1 db 0
L2 dw 1000
L3 db 12h
L4 dd 1A96h
L5 resb 1
L6 db "A"
L7 db 'word', 0
```

```asm
L8 times 100 db 0
L9 resw 100
```

> [!note] operation size not specified
> istruzioni come `mov [L6], 1` ritornano l'errore `operation size not specified`, dato che voglio muovere il valore immediato `1` all'indirizzo `L6`. Ma non so la grandezza del tipo immagazzinato in `L6`.
> Si risolve con `mov dword [L6], 1` per esempio.

> **Nota**: pagina 18 da tatuarsi.

## Creare un programma!
Fare riferimento ai sorgenti: `first.asm` e `driver.c`. Qui annotero' dettagli che meritano di essere snocciolati.

> **Nota**: le stringhe sono null terminated, perché verranno usate dalla libreria `C`.

> **Nota**: simboli per variabili e funzioni sono preceduti da `_` quando ci si interfaccia con `C`

> [!note] `enter o1, o2` e `leave` (chat gpt)
> `enter` crea un nuovo stack frame di grandezza `o2`, mettendo in questo anche il vecchio `ebp`.
> `leave` al contrario distrugge il vecchio stack frame.
> `o2` indica il *livello di annidamento*.

> **Nota (chat gpt)**: `enter` non si usa piu, e' poco prestante e poco flessibile. `leave` e' ancora usata tal volta.


> [!note] `global _asm_main`
> Definiamo un simbolo globale, ossia che puo' essere usato per risolvere altri oggetti.

*Come faccio a compilare e a fare il linking*?
* `gcc -o first driver.c first.o asm_io.o`
* `gcc -c driver.c` e poi `gcc -o first driver.o first.o asm_io.o`

> [!note] `nasm -l`
> Crea il listing-file, mostra come viene assemblato il sorgente.

*Interpretazione del listing-file*:

| 1a colonna     | 2a colonna                                 | 3a       | 4a                |
| -------------- | ------------------------------------------ | -------- | ----------------- |
| Numero di riga | Offset rispetto all'indirizzo del segmento | raw data | riga del sorgente |

> **Nota**: gli offset di ogni moduli non corrispondono a quelli finali, ossia ottenuti dopo il linking. Bisogna combinare e aggiustare gli indirizzi per avere dei segmenti unici.

Se andiamo a vedere le righe che riguardando il testo del programma, alcune label non possono essere risolte! In questo caso il valore dell'operando e' scritto tra parentesi quadre 

## Skeleton file
Questo codice e' la base di partenza per scrivere correttamente codice in assembly:

```asm
segment .data
segment .bss
segment .text
	global _asm_main
_asm_main:
	enter 0,0 
	pusha 
	
; il codice va qua!

	popa 
	mov eax, 0
	leave
	ret
```