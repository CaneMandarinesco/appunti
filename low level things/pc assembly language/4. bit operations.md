# operazioni di shift
## Shift logico
![[Pasted image 20251016233609.png]]
Viene fatto con `SHL` e `SHR` e servono per fare velocemente divisioni e moltiplicazioni a potenze di 2 su valori senza segno.

> **Nota**: l'ultimo bit in una shift, di fatto esce dal byte ed entra nella **carry flag**.

## Shifte aritmetico
Queste istruzioni fanno attenzione al bit che indica il segno, in modo da implementare lo shift (inteso come moltiplicazione e divisione per 2) su valori con segno.

* `SAL`: corrisponde a `SHL`
* `SAR`: i nuovi bit che entrano da sinistra sono copie del segno. Lo shift degli altri bit e' eseguito normalmente.
## Rotazione
Semplicemente, il bit che esce, diventa quello entrante, e si implementa con `ROL` o `ROR`. Il bit che esce viene copiato nella carry flag.

Invece, con `RCL` e `RCR` utilizzo anche il carry flag per lo shift, dunque usando per esempio `AX` come operando, in combinazione con `RCR` faccio di fatto una rotazione su 17 bit.

Grazie alla rotazione posso per esempio contare i bit accesi o spenti in un registro, grazie a `shl` e `jnc`.

# operazioni booleane
Niente di che, se gia conosci l'algebra booleana.

> **Nota**: `not` opera su un solo operando e trova il complemento a uno. (eventualmente sommando 1 ho trovato il complemento a due???)

> **Nota**: `test` esegue un `AND` senza salvare il risultato.

`AND` *puo' essere usata per trovare il resto di una divisione di una potenza di due*: basta applicare una maschera equivalente a $2^i -1$ se dividiamo per $2^i$.

Esempio 1:
```asm
	mov bl, 0
	mov ecx, 32
count_loop:
	shl eax, 1
	adc bl, 0
	loop count_loop
```
Conta i bit accesi in `eax`, con risultato in `bl`.

# evitare i branch condizionali
Le cpu fanno **speculative execution**. La cpu non sa a priori quale branch verrà presa, e provano quindi a predire la scelta che verrà fatta.

> **Nota**: Questo e' necessario perche' le CPU sono in grado di eseguire piu istruzioni in parallelo.

Istruzioni che fanno uso del carry (`ADC`) e le istruzioni `SETxx` permettono di rimuovere l'uso di controlli in certi casi.

Per esempio: `setz al` imposta `AL` a 1 se `Z` e' **set**.

Posso trovare il massimo tra due numeri senza usare **branch** condizionali:
```asm
xor ebx, ebx ; ebx = 0
cmp eax, [input1]
setg bl ; bl = 1 se [input1] e' il massimo
neg ebx ; se bl=1 allora ebx diventa -1
		; ossia: ebx=0xFFFFFFFF
		; se bl=0 allora ebx rimane 0x0
mov ecx, ebx
and ecx, eax
not ebx
and ebx, [input1]
or ecx, ebx
```

# manipolare i bit in c dio cane
...
# big e little endian
* **big endian**: intuitivo. I byte sono in memoria dal piu significativo al meno significativo.
* **little endian**: contrario di big endian. trovo primail byte meno significativo, e' il contrario di come si legge un numero.

test per little/big endian
```c
unsigned short word = 0x1234;
unsigned char *p = (unsigned char*) &word;

if(p[0] == 0x12)
	printf("big endian\n");
else
	printf("little endian\n");
```

Di base, non ce ne frega niente di che formato usa la cpu. Tuttavia `TCP/IP` richiede che gli interi siano immagazzinati come **Big Endian**.

Con `bswap`: posso invertire l'endianess di un dato.

# contare i bit
...

