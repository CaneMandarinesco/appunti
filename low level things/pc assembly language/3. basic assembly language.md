 # lavorare con gli interi
*Ci sono 3 metodi per rappresentare gli interi con segno*:
* `signed magnitude`: il bit piu significativo, se acceso, indica un numero negativo. Ma non funziona bene questa logica se applicata al modo in cui l'ALU fa le operazioni aritmetiche. Inoltre, ci sono due modi per rappresentare lo zero!
* `complemento a uno`: dato il numero positivo, il suo negativo lo trovo **invertendo** i bit! Anche qui ho due modi per rappresentare lo 0
* `complemento a due`: e' il metodo usato dai computer moderni. Il negativo si trova invertendo tutti i bit, e poi si aggiunge 1.

> **Nota**: assembly, o in generale, *la cpu non ha idea di che cosa rappresenti un byte in memoria*. In particolare non puo' determinare se il valore e' con segno o senza segno. *E' il programmatore che deve ricordarselo, ed usare quindi istruzioni per tipi con segno, o tipi senza segno.*

> **Nota**: definire in `C`  un intero con segno o senza segno, vuol dire che *suggerire al compilatore che tipo di istruzione deve usare su quella variabile*. Porcodio che figata!

## diminuire la grandezza di un dato
Con `AX=FFFFh` valore con segno, dunque $-1$ posso ridurlo ad $AL$ impostando a 0 i primi 8 bit, e ottengo come risultato `AL=FFh`, ossia $-1$. La stessa cosa pero' non vale per dati unsigned.

Dunque quando vogliamo ridurre un dato senza stravolgerne l'interpretazione, abbiamo due casi:
* `tipo unsigned`: allora i bit da rimuovere devono essere originariamente gia tutti a 0
* `tipo signed`: i bit da rimuovere sono tutti a `1` oppure tutti a `0`
## aumentare la grandezza di un dato
Piu complicato del caso precedente.

Se:
* devo estendere un **unsigned**, *allora aggiungo zeri*.
* devo estendere un tipo **signed**, *allora estendo il bit che indica il segno*.

Per gli unsigned posso usare:
```asm
movzx eax, ax ; estendi ax in eax
movzx eax, al ; estende al in eax
movzx ax, al  ; estende al in ax
movzx ebx, ax ; estende ax in ebx
```

Per numeri con segno si usano le istruzioni apposite:
* `cbw`: estende byte in word, quindi per esempio `AL` in `AX`
* `cwd`: estende `AX` in `DX:AX`
* `movsx`: funziona anche con signed

## estensione in `C`
Considera questo codice che contiene un **bug**!
```c
char ch;
while((ch = fgetc(fp)) != EOF){
	/* do something incredible */
}
```

Analizzando il prototipo di `fgetc` ritorna un intero, ma perchÃ© mai? (non dovrebbe ritornare dei caratteri?). Il fatto e' che puo' ritornare `EOF`, ossia `-1` e il modo in cui `-1` viene adattato a `char` dipende se e' definito come tipo con segno, oppure senza segno.

> **Nota**: nella seconda riga, `int` ritornato da `fgetc` viene ridotto a `char` e poi esteso a `int`. In caso `char` sia `unsigned` arrivo a confrontare `0x000000FF` con `0xFFFFFFFF`! (ecco il **bug**)

> **Nota**: l'altro bug sta nel fatto che potrebbe essere letto il carattere `0xFF`, che confrontato con `EOF` in caso `ch` sia con segno, porta alla terminazione del loop.

> **Nota**: il comportamento dipende da come il compilatore di `C` decide di estendere o contrarre i dati.
## Aritmetica in complemento a due
In `EFLAGS` troviamo i `overflow` e `carry flag` :
* `overflow`: impostato se il valore con segno non puo' essere immagazzinato nella grandezza del dato di destinazione.
* `carry falg`: impostata se avviene un carry o un borrow nel `msb`

> **Nota**: questi flag sono impostati secondo il risultato di `add` o `sub`.

> **Nota**: esistono `mul` e `imul`, rispettivamente per `unsigned` e `signed` perche' la moltiplicazione e' implementata in due modi diversi. (stesso discorso per `div` e `idiv`)

*Con `mul source` faccio una moltiplicazione con un riferimento in memoria o un registro da usare come sorgente.* La destinazione e' sempre il registro `AL,AX,EAX`.

> [!warning] `mul source` e `imul`
> * In `mul` non posso selezionare  come sorgente un valore **immediato**.
> * In `idiv`

Per `imul` posso usare le seguenti combinazioni di operandi:
![[Pasted image 20251015205627.png]]

Per `div` invece in base alla grandezza dell'operando, cambiano le coppie di registri usati per quoziente e resto:

| source   | dest (quoziente e resto) |
| -------- | ------------------------ |
| `8-bit`  | `AL:AH`                  |
| `16-bit` | `DX:AX`                  |
| `32-bit` | `EDX:EAX`                |

> **Nota**: se il quoziente e' troppo grande per entrare nel registro il programma e' interrotto e termina. (oss: potrebbe essere una causa dell'errore della divisione per 0???)

# Esempio
*Vediamo come a  cosa serve `cdq`, nell'ambito di una divisione con segno*:
```asm
mov eax, ebx
cdq          ; fai estensione del segno su edx:eax
mov ecx, 100
idiv ecx     ; edx:eax / ecx
			 ; per dividere correttamente ho bisogno di cdq 
mov ecx, eax
mov eax, quot_msg
call print_string 
```


*Ipotizzando di voler sommare `EDX:EAX` con `EBX:ECX` allora*:
```asm
add eax, ecx ; calcola ed eventualmente imposta il carry
adc edx, ebx ; somma anche il carry al primo bit
```

Stessa cosa avviene con `sub`, e per numeri **molto grandi** si puo' implementare l'aritmetica con `loop` e `CLC` per pulire il bit di carry.

# Strutture di controllo
`CMP` *permette di effettuare confronti e di aggiornare `FLAGS` in base alla differenza dei due operandi, senza immagazzinarne il risultato.*
Le flag importanti sono `ZF` e `CF`.

`cmp vleft, vright` calcola `vleft - vright` e imposta le flag.
* se `vleft = vright` allora: `ZF=1` e `CF=0`
* se `vleft > vright` allora: `ZF=CF=0`
* se `vleft < vright` allora: `ZF=0` e `CF=1`

Per i tipi **con segno** sono importanti `ZF`, ed:
* `OF`: impostato se avviene un overflow o un underflow
* `SF`: se il risultato e negativo

Sempre nell'abito dei tipi **con segno**:
* se `vleft > vright`: `SF=OF`. (**ragionaci un po'**)
* se `vleft < vright`: `SF!=OF`. 

>[!warning] `flags`
>Altre istruzioni possono modificare `FLAGS`.

*Le istruzioni di **branch** trasferiscono l'esecuzione a punti arbitrari del programma*. Possono essere condizionali o `unconditional`.

La `jmp` permette un salto non condizionale e in linguaggio assemblativo prende come parametro di solito una label che viene rimpiazzata dall'assemblatore con l'indirizzi corrispondente.

Ci sono vari tipi di jump:
* **SHORT**: mi posso muovere dall'indirizzo corrente di 128 byte. Questo tipo usa un solo byte interpretato con segno per specificare l'offset.
* **NEAR**: nel `80386` si puo fare near jump con 2 o 4 byte.
* **FAR**: mi permette di cambiare segmento, che non succede quasi mai in codice protetto per `386`.

Esempio 1:
```c
if (EAX == 0)
	EAX = 1;
else
	EAX = 2;
```
diventa:
```asm
	cmp eax, 0
	jz then
	mov ebx, 2
	jmp next
thenblock:
	mov ebx, 1
next:
```

*Esempio 2*:
```c
if (EAX >= 5)
	EBX = 1;
else 
	EBX = 2;
```
diventa:
```asm
	cmp eax, 5
	js signon    ; controlla se sign=1
	jo elseblock ; se overflow=1 e sign=0
	jmp thenblock
signon:
	jo thenblock ; controlla se overflow=1
elseblock:
	mov ebx, 2
	jmp next
thenblock:
	mov ebx, 1
```

**L'esempio 2** e' strano ma copre *tutte le combinazioni possibili per le flag overflow e sign*. Per questo esistono delle istruzioni che ci semplificano la vita:
![[Pasted image 20251016232635.png]]

Allora il codice dell'esempio 2 diventa:
```asm
	cmp eax, 5
	jge thenblock
	mov ebx, 2
	jmp next
thenblock:
	mov ebx, 1
next:
```

*Per implementare i **loop** usiamo*:
* `LOOP`: decrementa `ECX`, se `ECX!=0` vai alla label.
* `LOOPE`, `LOOPZ`: decrementa `ECX`, se `ECX!=0` e `ZF=1` salta.
* `LOOPNE`, `LOOPNZ`: decrementa `ECX`, se `ECX!=0` e `ZF=0` allora salta.

> **Nota**: la sottrazione a `ECX` non modifica `FLAGS`.

**Esempio 3**:
```c
sum = 0;
for(i=10; i > 0; i--)
	sum += i;
```
diventa:
```asm
	mov eax, 0
	mov ecx, 10
loop_start:
	add eax, ecx
	loop loop_start
```