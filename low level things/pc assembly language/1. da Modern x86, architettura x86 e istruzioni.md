Dal libro `Modern x86 assembly language`.
# data types
## tipi fondamentali
Sono `byte, word, doubleword, quadword, double quadword` e `quad quadword`, dove ogni tipo ha il doppio dei bit del precedente.

> **Nota**: `Quintword` ha `80 bit`, e viene usata dalla `x87 FPU`

> **Nota (chat gpt)**: secondo, non esiste ufficialmente il tipo`quad quadword`.

> [!note] `quintword` (**chat gpt**)
> La `quintword` da `80 bit` non e' un vero e proprio tipo, piu che altro e' il formato usato dalla `FPU` per computazioni su `long duble`

> [!note] dati multibyte: little endian
> I dati multibyte sono mantenuti in memoria come sequenza di byte, dove l'indirizzo piu basso si colloca nel **byte meno significativo** (little endian).

> [!note] allineamento
> I dati devono essere allineati! Per esempio, l'indirizzo di una word deve essere divisibile per 2, la doubleword per 4, ecc...
>
> Il mancato allineamento comporta **problemi di performance**, ed alcune istruzioni non eseguono se non allineate.
> Comunque, anche se le parole non sono allineate, l'esecuzione spesso procede comunque, anche se con problemi di performance.
> 

## tipi numerici
> **Nota**: sono rappresentati usando i tipi fondamentali

I tipi numerici **scalari**, sono usati per calcoli con valori discreti, ossia quelli che vengono usati in linguaggi come `C`: `signed int`, `unsigned int`, `floating point`

> **Nota**: `signed/unsigned integer` hanno le varianti a `8 16 32 64` bit. `float` e' rappresentabile a `32, 64 e 80`, ossia `float, double e long double`.

> **Nota (chat gpt)**: i floating point sono rappresentati usando `IEEE-754`.

## tipi packed
Sono usati per le istruzioni `SIMD`, per calcoli su interi o float:
* un tipo a `64 bit` puo' essere usato per tenere `8` byte, oppure 4 da `16 bit`, ecc...

**Packed size**: definisce la grandezza del tipo, su questa poi definisco il **Data Element Type**, ossia la suddivisione in bit del tipo packed.

## altri tipi
**Stringhe**: *ossia un blocco contiguo di dati dello stesso tipo* (`byte, word, ...`) e sono usati per processare testo, array, bitmap e altre strutture dati di questo tipo. `x86` ha delle istruzioni in grado di operare su stringhe.

> **Nota (chat gpt)**: secondo chat, **per definizione** le stringhe sono blocchi di memoria adatti ad essere manipolate dalle istruzioni per stringhe! 

**BCD** (Binary Coded Decimal): *per rappresentare cifre da 0 a 9 usando interi senza segno a 4 bit*.

# architettura interna
L'architettura puo' essere partizionata in:
* core execution unit (**chat gpt**: che comprende pipeline, ALU, AGU)
* `x87 FPU`
* `SIMD` unit

![[Pasted image 20251013213307.png]]
## segment registers
Servono per definire una **memoria logica** per l'esecuzione dei programmi e per immagazzinare i dati di questi.

In **protected mode**, i segment registers sono usati per accedere alla Descriptor Table dove e' definito il segmento a cui sto accedendo.

## General purpose
![[Pasted image 20251013213748.png]]

> **Nota**: nonostante siano general purpose, l'instruction set spesso impone delle restrizioni su quali possono essere effettivamente usati.

Esempi di limitazioni e di registri speciali:
* `imul` e `idiv` usano `EDX` per tenere la doubleword piu alta del prodotto o del dividendo.
* Le operazioni su stringhe fanno riferimento a `ESI` ed `EDI`, e usano `ECX` come contatore per le ripetizioni.
* `ESP`: viene usato come stack pointer, **e punta sempre all'elemento piu in alto**!
* `EBP`: punta alla base dello stack e viene usato per accedere ai dati in questo salvati

In particolare, quando si scrive in `x86` si tiene in mente che:

| reg | uso convenzionale                                                               |
| --- | ------------------------------------------------------------------------------- |
| eax | accumulator                                                                     |
| ebx | puntatore in memoria, base register                                             |
| ecx | loop control, counter                                                           |
| edx | `imul` e `idiv`                                                                 |
| esi | string source pointer                                                           |
| edi | string destination pointer                                                      |
| esp | stack pointer, *punta all'elemento piu in cima*, ossia piu recente e piu basso. |
| ebp | stack frame base pointer, (**chat gpt**) puo' essere anche generale.            |
## Registro EFLAGS
Contiene dei bit di stato. Questo registro viene usato dalla cpu per indicare risultati di operazioni logiche e aritmetiche e un insieme di bit usati principalmente nel contesto di esecuzione dei sistemi operativi.

Di queste flag ci interessano solo:
* `AF`: auxiliary carry flag (usata con `bcd`)
* `CF`: carry flag (overflow in aritmetica senza segno)
* `OF`: overflow flag
* `PF`: parity flag
* `SF`: sign flag
* `ZF`: zero flag
* `DF`: direction flag, indica gli effetti delle istruzioni su stringhe sui registri `ESI/EDI`
	* `DF=1` allora ad ogni istruzione **decrementa** `ESI/EDI
	* `DF=0` allora ad ogni istruzione **incrementa** `ESI/EDI`

## EIP
Contiene l'**offset della prossima istruzione** da eseguire.

## Operandi
Le istruzioni usano di solito degli operandi! Ossia: su quali valori deve operare una certa istruzione?

Ci sono tre tipi di operandi:
* `immediate`: e' un valore costante codificato nell'istruzione vera e propria! *Solo l'operando sorgente puo' essere immediate*
* `register`: in un general purpose register, viene utilizzato il suo valore.
* `memory`: un'indirizzo in memoria. *Sorgente e destinazione non possono essere entrambi di tipo memory*

> `mul ebx`: questa istruzione equivale a `edx:eax = eax * ebx` dove `edx:eax` vuol dire che il registro `eax` viene esteso con `edx`.
> Gli operandi sono `eax` ed `ebx` ma posso specificare solo il secondo!

> `sub word ptr [edi],12` equivale a `*(short*)edi -= 12` dove `word ptr` indica all'assembler che `[edi]` e' un puntatore a una `word`. Senza `word ptr`, il contenuto di `[edi]` sarebbe ambiguo: e' una word? una doubleword? non e' specificato da nessuna parte!

## Memory Addressing
Ora, come sono calcolati gli indirizzi nel caso di un `memory operand`?
Viene usata la formula `Effective Addr = BaseReg + IndexReg * ScaleFactor + Disp` dove:
* `BaseReg`: un qualsiasi registro general purpose.
* `IndexReg`: un qualsiasi registro general purpose, tranne `ESP`
* `Disp`: costante e codificato nell'istruzione
* `ScaleFactor` assume uno tra questi valori: $1,2,4,8$

> **Nota** **(chat gpt)**: `BaseReg` e `IndexReg` devono essere entrambi a 32 o 64 bit.

>  `BaseReg + IndexReg * SF + Disp` si ha con: `mov eax,[ebx+esi*4+20]`.

# Instruction set
Molte istruzioni usano i Condition Code:

| Condition Code         | Mnemonic | Test Condition        |
| ---------------------- | -------- | --------------------- |
| Above                  | A        | `CF == 0 && ZF == 0`  |
| Neither below or equal | NBE      |                       |
| Below                  | B        | `CF == 1`             |
| Above or equal         | AE       | `CF == 0`             |
| Equal                  | `E`      | `ZF == 1`             |
| Greater                | `G`      | `ZF == 0 && SF == OF` |
| Less                   | `L`      | `SF != OF`            |
e altri che stanno sul libro.

> **Nota**: le condizioni come `above` e `below` si applicano a interi unsigned. Invece greather e less a interi con segno.

## Data transfer

| mnemonic | description                                                                                                        |
| -------- | ------------------------------------------------------------------------------------------------------------------ |
| `mov`    | copia dati!                                                                                                        |
| `cmovcc` | copia condizionale! dove `cc` e' una delle condizioni viste prima.                                                 |
| `push`   | Sottrai a `ESP` il valore `4` e carica in `ESP` il valore dell'operando.                                           |
| `pop`    | Esattamente il contrario di `push`, preleva e somma `4`                                                            |
| `pushad` | Metti tutti i registri general purpose nello stack                                                                 |
| `popad`  | Preleva tutti i registri general purpose dallo stack                                                               |
| `xchg`   | Scambio di valore tra due operandi. Se e' coinvolta una locazione di memoria, viene acquisito il **lock** del bus. |
| `xadd`   | Scambia dati tra registri e sommali nell'operando di destinazione.                                                 |
| `movsx`  | estendi con **s**egno e copia                                                                                      |
| `movzx`  | estendi con **z**eri e copia                                                                                       |


## Aritmetica Binaria

| mnemonic | description                                                                                                                                                                            |
| -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `add`    | somma degli operandi sorgente e destinazione                                                                                                                                           |
| `adc`    | come `add` ma viene sommato il valore di `EFLAGS.CY`                                                                                                                                   |
| `sub`    | contrario di `add`                                                                                                                                                                     |
| `sbb`    | contrario di `adc`                                                                                                                                                                     |
| `imul`   | moltiplicazione con segno, prende 2 operandi. Esiste una variante a 3 operandi  che prende: `immediate source, memory/register src, GPR dest`.<br>**Nota**: ad un operando, usa `EAX`! |
| `mul`    | moltiplicazione senza segno                                                                                                                                                            |
| `idiv`   | salva il quoziente e il resto in `EDX:EAX`                                                                                                                                             |
| `div`    | come `idiv` salva in `EDX:EAX`                                                                                                                                                         |
| `inc`    | non ha effetto su `CY`                                                                                                                                                                 |
| `dec`    | come `inc`                                                                                                                                                                             |
| `neg`    | complemento a due del valore, ossia `0 - val`.                                                                                                                                         |
| `daa`    | aggiusta il contenuto di `AL` dopo una `add` su valori packed `bcd`                                                                                                                    |
| `das`    | come `daa` ma a eseguito di `sub`                                                                                                                                                      |
| `aaa`    | come `daa` ma su `bcd` unpacked.                                                                                                                                                       |
| `aam`    | unpacked per `mul`                                                                                                                                                                     |
| `aad`    | unpacked per `div`                                                                                                                                                                     |
Le ultime istruzioni servono a correggere il valore per il formato `bcd` a seguito di un'istruzione.

## Data comparison

| mnemonic           | description                                                                                                                           |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| `cmp`: **compara** | usato in combinazione con `jcc, cmovcc, setcc`. Fa la sottrazione  **per comparare**  due operandi e aggiorna `EFLAGS` di conseguenza |
| `cmpxchg`          | compara `AL,AX o EAX` con la destinazione e fa lo scambio in base al risultato                                                        |
| `cmpxchg8b`        | compara `EDX:EAX` con un valore a 8byte e scambia in base al risultato.                                                               |

## Data conversion

Estensione segno:

| mnemonic | description                                 |
| -------- | ------------------------------------------- |
| `cbw`    | Estendi con segno `AL` e salva in `AX`      |
| `cwde`   | Estendi con segno `AX` e salva in `EAX`     |
| `cwd`    | Estendi con segno `AX` e salva in `DX:AX`   |
| `cdq`    | Estendi con segno`EAX` e salva in `EDX:EAX` |

altri:

| mnemonic | description                                                                                                     |
| -------- | --------------------------------------------------------------------------------------------------------------- |
| `bswap`  | Inverti i byte in un GPR, ossia conversione tra little endian e big endian                                      |
| `movbe`  | Carica il source operand in un registro temporaneo, inverti byte, salva risultato nell'operando di destinazione |
| `xlatb`  | Converti il valore in `AL` in un'altro valore usando la **lookup table** puntata da `ebx`.                      |

## Logical
Queste istruzioni operano sulle **flag**!

| mnemonic | description                                              |
| -------- | -------------------------------------------------------- |
| `and`    | Bitwise `and` tra sorgente e destinazione                |
| `or`     | Come prima, ma bitwise `or`                              |
| `xor`    | ...                                                      |
| `not`    | **Complemento a uno**, senza modificare le status flag   |
| `test`   | come `and`, ma non salva il risultato, aggiorna le flag. |

## Rotazione
| mnemonic  | description                                                                  |
| --------- | ---------------------------------------------------------------------------- |
| `rcl`     | rotazione verso sinistra, con `EFLAGS.CY` incluso come bit per la rotazione. |
| `rcr`     | come prima, verso destra.                                                    |
| `rol`     | rotazione a sinistra                                                         |
| `ror`     | rotazione a destra                                                           |
| `sal/shl` | shift a sinistra aritmetico                                                  |
| `sar`     | shift a destra aritmetico                                                    |
| `shr`     | shift logico verso destra                                                    |
| `shld`    | double-precision logical left shift, con 2 operandi                          |
| `shrd`    | double-precision logical right shift, con 2 operandi                         |

## Byte Set e Bit String
| mnemonic | description                                                     |
| -------- | --------------------------------------------------------------- |
| `setcc`  | imposta byte di destinazione nell'operando a 1 se `cc` e' vera. |
| `bt`     | copia il test bit in `CY`                                       |
| `bts`    | copia il test bit in `cy`, e mettilo a 1 (`SET`)                |
| `btr`    | come prima, ma metto a 0 (`reset`)                              |
| `btc`    | fa il toggle di `CY`                                            |
| `bsf`    | ...                                                             |
| `bsr`    | ...                                                             |

## Stringhe
| mnemonic                  | description                                                                                      |
| ------------------------- | ------------------------------------------------------------------------------------------------ |
| `cmpsb`, `cmpsw`, `cmpsd` | Compara i valori le locazioni di memoria indicate da `ESI` ed `EDI`                              |
| `lodsb`, `lodsw`, `lodsd` | Carica il valore puntato da `ESI` in `AL,AX oppure EAX`                                          |
| `movsb`, ...              | Copia il valore puntato da `ESI` nella locazione puntata da `EDI`                                |
| `scasb`, ...              | Compara il valore puntato da `EDI` con il registro `AL,AX o EAX`                                 |
| `rep`                     | Ripeti la string instruction specificata, finche `ecx!=0` e decrementa `ECX` ad ogni iterazione. |

## Flag Manipulation
| mnemonic | description                                        |
| -------- | -------------------------------------------------- |
| `clc`    | `EFLAGS.CY=0`                                      |
| `stc`    | `EFLAGS.CY=1`                                      |
| `cmc`    | toggle `EFLAGS.CY`                                 |
| `std`    | `DF=1`                                             |
| `cld`    | `DF=0`                                             |
| `lahf`   | carica in `ah` lgli status flag                    |
| `sahf`   | carica in `EFLAGS` i bit specificati in `ah`       |
| `pushfd` | metti le flag nello stack                          |
| `popfd`  | preleva la parola dallo stack e mettila in eflags. |

> **Nota**: `lahf` e `sahf` non hanno effetto sui bit di sistema.
## Control Transfer
| mnemonic                             | description                                                       |
| ------------------------------------ | ----------------------------------------------------------------- |
| `jmp`                                | Fai un salto non condizionale alla locazione specificata          |
| `jcc`                                | Salto condizionale con `cc` condizione                            |
| `call`                               | metti `EIP` nello stack e fai il jump non condizionale            |
| `ret`                                | fa il pop del target address dallo stack e fai salto verso questo |
| `enter` e `leave`                    | usati per creare e distruggere frame stack                        |
| `jecxz`                              | salta se `ECX == 0`                                               |
| `loop`                               | `ecx--` e salta se `ECX==0`                                       |
| `loope`, `loopz`, `loopne`, `loopnz` | lapalissiano???                                                   |