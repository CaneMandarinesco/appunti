##  `page tables`
L'**indirizzo virtuale** e' costituito da:
* `27-bit` di `index`, usati per ottenere l'associazione tra `PTE` (Page Table Entry) e `PPN` (Page Table Number)
* `12-bit` che sono usati **cosi come sono** nell'indirizzo fisico

La **traduzione** sta nel sostituire i `27-bit` di `index` con i `44-bit` di `PPN`, specificati nella `PTE`.

La page table e' navigata **in tre step**, come un'albero a 3 livelli:
* la **radice** contiene 512 `PTE`. (selezionabile con i primi `9-bit` dei `27`)
* ogni figlio ha 512 `PTE`. (altri `9-bit`)
Gli ultimi `9-bit` selezionano la `PTE` finale.

> L'organizzazione ad albero e' migliore rispetto ad un'unica grande tabella per questioni di uso effettivo memoria. Se uso poca memoria devo comunque allocare tutta la page table, che e' molto grande!

> Ogni `PTE` ha informazione sul `PPN` associato e sulle flag per quella pagina, per esempio permessi di lettura e scrittura.

> Quando viene richiesto un'indirizzo e questo non e' presente nella Page Table, viene generata una `page-fault exception` che viene gestita dal kernel.

![[Pasted image 20250826181125.png]]

Le flag associate ad ogni `PTE` sono: 
* `PTE_V`: la `PTE` e' presente e allocata? Se `unset` allora l'indirizzo di memoria causa un page fault
* `PTE_W, PTE_R, PTE_X`: posso leggere, scrivere o eseguire?
* `PTE_U`: posso eseguire la pagina in user mode?

> [!note] `stap` register
> Il registro e' usato per implementare la paginazione e contiene l'indirizzo che punta alla `PTE` radice, da usare per convertire gli indirizzi. 
> Ogni `CPU` ha il suo `stap` register.

## spazio indirizzi del kernel
Ogni processo ha la sua page table, mentre il kernel ne ha una.

Ma come e' organizzata fisicamente la memoria? `QEMU` simula un computer dove la `RAM` inizia a `0x80000000=KERNBASE` e finisce almeno dopo `0x88000000=PHYSTOP`.

![[Pasted image 20250826184342.png]]

Alcuni indirizzi e' meglio non mapparli usando la memoria virtuale ma piuttosto si usano indirizzi fisici. Quando per esempio `fork` alloca memoria `utente` per il processo figlio viene ritornato l'indirizzo fisico di quella memoria. 

Altre aree di memoria non hanno mappatura virtuale come:
* `trampoline page` che si trova in cima allo spazio degli indirizzi.
* `kernel stack pages`: ogni processo ha il suo `kernel stack`, limitato dalla `guard page`, una pagina che genera kernel panic quando si tenta l'accesso.

Visto che non ci ho capito un cazzo...
### vediamo il codice
> guardando `pagetable`

`pagetable_t` e' la struttura dati fondamentale, ossia un semplice puntatore ad un `uint64` e punta alla root page-table.

> [!note] `pte_t * walk(pagetable_t pagetable, uint64 va, int alloc)`
> * `pagetable`: la page table da navigare.
> * `va`: e' il `virtual address` da tradurre.
>  * `alloc`: se non riesco a navigare la page table, dovrei allocare?
>  
> Trova la `PTE` per un'indirizzo virtuale facendo quello che fa la memoria virtuale: naviga con un ciclo `for` i 2 livelli della page table.
> Se ad ogni livello la `PTE` non e' allocata, allora provvede a farlo se l'argomento `alloc` e' stato impostato.

Nel codice di `walk`:
* `pte_t *pte = &pagetable[PX(level, va)];` ossia dato `level` e `va`, estrai l'offset nella page table per ottenere `pte`.
* se `pte` ha il bit `PTE_V` impostato (ossia e' valida) allora posso usare la `pte`
* `pagetable = (pagetable_t)PTE2PA(*pte);` prepara per la prossima iterazione.
* `PTE2PA` ottiene da `pte` l'indirizzo fisico facendo degli shift (infatti `pte` contiene direttamente l'indirizzo insieme alle flag, bisogna solo estrarlo correttamente)

`PX` e `PTE2PA` sono delle semplici macro che fanno delle operazioni di shifting, la prima ottiene l'offset per navigare la page table di livello `level`, la seconda preleva da `pte` l'indirizzo fisico!

> [!note] `int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)`
> * `va`: indirizzo virtuale da usare
> * `pa`: indirizzo fisico da associare
> 
> Crea le `PTE` necessarie usando `walk` con `alloc=1`, poi posso popolare la `pte` ottenuta con `*pte = PA2PTE(pa) | perm | PTE_V;`.
> Il ciclo `for(;;)` termina quando ho creato il numero di pagine che esaurisce la grandezza indicata.

> `PA2PTE` trasforma un indirizzo fisico arbitrario nel formato giusto per immagazzinarlo nella `PTE` insieme agli altri attributi.

> [!warning] ma a che serve `mappages` in `kvminit`?
> Cosa succederebbe se accendiamo la memoria virtuale senza aver mappato niente? Essendo la page table vuota non sarei in grado di leggere niente, quindi devo quanto meno mappare gli indirizzi fisici che conosco (testo del kernel, ecc...), cosi quando accendo la memoria virtuale non ho trap.

> **Nota**: le procedure che iniziano con `kvm` interagiscono con page table del kernel.

Nella sequenza di boot, viene chiamato `kvminit` che crea la kernel page table usando `kvmmake`, il tutto prima di abilitare il paging quindi tutti gli indirizzi usati sono fisici.

> [!note] `kvmmake`
> alloca lo spazio per tenere la page table usando `kalloc` (ritornando una pagina da `4KB`).
> Successivamente vengono fatte le mappature essenziali con `kvmmap`.
> Con `proc_mapstacks` vengono mappati i kernel stack per ogni processo!

> [!note] `kvmmap`
 Con `kvmmap` vengono installate le traduzione di cui il kernel ha bisogno. Non fa altro che chiamare `mappages`, che a sua volta usa `walk` come visto prima.

> [!note] `proc_mapstacks` in `kernel/proc.c`
> Per ogni processo viene chiamato `kalloc` che ritorna un indirizzo fisico. Questo deve essere mappato ad un'indirizzo conosciuto, ottenuto usando la macro `KSTACK`. 
> Con `kvmmap` viene effettuata la mappatura.
> L'obiettivo e' mappare le pagine create con `kalloc` in alto, come da design.
> 

> [!note] `kvminithart`
> Installa la kernel page table nella cpu, scrivendo l'indirizzo della root page table nel registro `satp`. Dopo cio' la memoria virtuale e' abilitata.

## `kalloc.c`
Utilizza una `free list`, dove ogni elemento libero e' rappresentato da `struct run`. 

> **Nota**: la struttura dati e' immagazzinata dentro lo spazio per le pagine

> Nota: la `struct run` e' protetta da `spinlock`

Infatti: `kinit`, chiama `freerange`, la `freelist` e' inizializzata in modo da tenere ogni pagina tra la fine del kernel e `PHYSTOP`.
```c
void
freerange(void *pa_start, void *pa_end)
{
	char *p;
	p = (char*)PGROUNDUP((uint64)pa_start);
	for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
		kfree(p);
}
```

e `kfree` si occupa di liberare quella pagina, ripendola con valori **garbage**:
```c
void
kfree(void *pa)
{
	struct run *r;
	
	if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
		panic("kfree");
		
	memset(pa, 1, PGSIZE);
	r = (struct run*)pa;
	
	/* aggiungi la pagina alla free list */
	acquire(&kmem.lock);
	r->next = kmem.freelist;
	kmem.freelist = r;
	release(&kmem.lock);
}
```

in `kalloc` viene presa la prima pagina libera, viene fatto il `memset` a 5 (utile per il debug della memoria). con `if(r)` si controlla se la memoria e' effettivamente libera, se `r=0` viene ritornata comunque ma chi usa `kalloc` sa che e' invalida.
```c
void *kalloc(void){
	struct run *r;
	
	acquire(&kmem.lock);
	r = kmem.freelist;
	if(r)
		kmem.freelist = r->next;
	release(&kmem.lock);
	
	if(r)
		memset((char *)r, 5, PGSIZE);
	return (void *)r;
}
```

# proc address space
> **Nota**: ogni processo ha la sua page table.

La memoria di un processo utente fa da `0` a `MAXVA`, permettendogli di indirizzare 256 gigabyte di memoria.

Lo spazio degli indirizzi di un processo e' costituito da:
* **testo** del programma, le cui pagine non hanno il permesso `PTE_W`! (non serve, se ci fosse, sarebbe dannoso)
* **dati** del programma
* **stack**
* **heap**

> **Nota**: Le stringhe che contengono gli *argomenti della riga di comando* (ossia, un'array di puntatori) si trovano in cima allo stack!

Per rilevare overflow nello stack viene inserita una **pagina di guardia** sotto lo stack, ma un sistema operativo serio allocherebbe piÃ¹ pagine per lo stack.

L'heap e' in grado di crescere se un processo richiede piu memoria di quante glie ne e' stata fornita.

### `sbrk`
La chiamata di sistema `sbrk` permette di restringere o allargare la memoria di un processo ed e' implementata da `growproc` in `kernel/proc.c` che usa:
* `uvmalloc`: alloca memoria usando `kalloc` e mappa la pagina alla user page table
* `uvmunmap`: usa `walk` per trovare le `PTE` e le libera.

### `exec`
E' una chiamata di sistema che rimpiazza l'user address space di un processo con dati letti da un file il cui `path` viene aperto usando `namei`. 

Del file viene letto l'`ELF` header, seguendo il formato `ELF`, definito in `elf.h`. Un file `ELF` e' costituito da un header, ossia `struct elfhdr` seguito da una sequenza di `program section headers`, ossia sezioni dell'applicazione da caricare in memoria, principalmente due: *uno per il testo del programma e uno per i dati*.

> **Nota**: un binario `ELF` inizia con il magic number `0x7F`, `E`, `L`, `F`. Viene controllato da `exec`.

Con `proc_pagetable` (`exec.c`) viene creata una nuova page table, questa viene popolata da `uvmalloc` e `loadseg` che associano alla page table i segmenti dell'`ELF`.

> `loadseg`: usa `walkaddr` per trovare l'indirizzo fisico e `readi` per leggere dal file.

`exec` alloca e inizializza lo stack copia gli argomenti in cima allo stack e mette i puntatori a questi in `ustack`. Viene piazzato un null pointer alla fine di `argv`. I valori di `argc` e `argv` sono passati al main tramite syscall usando i registri `a0: argc` e `a1: argv`.l