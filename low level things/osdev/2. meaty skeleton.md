Nel nostro sistema host, abbiamo una cartella `sysroot` che vogliamo usare come root: qui verrano installati tutti i programmi e librerie che servono al kernel per essere operare.

Vogliamo una cartella per gli `header` di sistema, ossia `sysroot/usr/include` e una cartella per i binari, ossia `sysroot/usr/lib`, mentre il binario del kernel lo buttiamo in `sysroot/boot`

> **Nota**: conviene sempre usare questo schema! per ragioni che verrano poi mostrate.

Il compilare ha `system root` support, dunque cerchera i binari per il linking in `/usr/lib`. Inoltre con la flag `--witouth-headers` per il compilatore, evitiamo l'uso di `usr/include` dato che non abbiamo una libreria standard c da utilizzare!

> **Nota**: posso passare `-isystem=/usr/include` per specificare una cartella per gli header.


> [!warning ] non ho capito
### sys header
`./headers.sh` e' uno script che installa gli header in `sysroot/usr/include` 

> [!warning ] non ho capito


### Makefile design
Andiamo a creare il makefile (file che pilota il compilatore, nel fare scelte intelligenti e corrette per compilazione e linking).

```make
CFLAGS?=-O2 -g
CFLAGS:=$(CLAGS) -Wall -Wextra
```

dove `?=` vuol dire assegna il valore a sinistra se la variabile non e' definita.

### `libc` e `libk`
Ci sono due versioni della standard library: `freestanding` e `hosted`.

La **freestanding**, ossia `libk`, non contiene chiamate di sistema! implementa tutto da sola.

Il compilatore `gcc` richiede di implementare alcune procedure come `memcpy`

## `boot.S`
Si dichiara la sezione `.multiboot` che contiene le informazioni e il magic number per riconoscere l'immagine come bootabile.

Nella sezione `.bss` viene definito uno stack da `16Kib`

> **Nota**: viene definito `_start` come simbolo globale, visibile ad altri oggetti.

Successivamente:
* `call _init`: ossia il costruttore
* `call kernel_main`

Prima di `call _init`, inizializzo lo stack, il `BIOS` non lo in

Domande:
* perche' `.section .bss` ha `.align 16`?

### `crti.S`
* `_init` salva il vecchio stack e inizia dalla nuova posizione.
* `_fini` ripristina lo stack

`gcc` estende questi due simboli con altre istruzioni


### `crtn.S`
definisce due sezioni:
* `init`: che fa `popl %ebp`
* `fini`: che fa `popl %ebp`
ossia recuperano il vecchio stack frame.

### `linker.ld`

* `. = 1M`: vuol dire che l'immagine del kernel si trovera' alla locazione che comincia da `1Mib`.
* La sezione `.text` contiene `.multiboot` e poi il testo del programma.
* `ENRTY(_start)`: specifichiamo l'entry point!

### `kernel.c`
Si occupa di inizializzare il terminale su `vga` e stampa una stringa

### `tty.c` e `vga.h`
L'implementazione del terminale, scrivendo direttamente caratteri sul buffer `VGA`.

### `libc`
Contiene l'implementazione delle procedure base della libreria c richieste dal compilatore ???????