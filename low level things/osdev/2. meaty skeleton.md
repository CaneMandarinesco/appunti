Variabili d'ambiente da impostare per compilare:
```bash
export PREFIX="$HOME/opt/cross"
export TARGET=i686-elf
export PATH="$PREFIX/bin:$PATH"
```

> [!warning] `--with-sysroot`
> You _must_ configure your cross-binutils with the --with-sysroot option, otherwise linking will mysteriously fail with the _this linker was not configured to use sysroots_ error message. If you forgot to configure your cross-binutils with that option, you'll have to rebuild it, but you can keep your cross-gcc.
### sys root
Normalmente il sistema operativo cerca gli header in `/usr/include` oppure `/usr/lib`.

Nel nostro caso, compiliamo un sistema operativo e vogliamo le nostre directory con i nostri header:
* `myos/sysroot/usr/include`
* `myos/sysroot/usr/lib`

Dove `sysroot` e' la "cartella root" del sistema da compilare: *che poi diventerÃ  il layout del file system del sistema*.

> [!note] `-elf`
> I target `-elf` (dunque `i686-elf-gcc`) non hanno uno `user-space`

Il cross-compiler e' stato costruito con la flag: `--without-headers`: dunque non cerca gli header per includere la standard library, quindi possiamo specificarne una noi!

> [!warning] boh
> The -elf targets have no user-space and are incapable of having one. We configured the compiler with system root support, so it will look in ${SYSROOT}/usr/lib as expected. We prevented the compiler from searching for a standard library using the --without-headers option when building i686-elf-gcc, so it will _not_ look in ${SYSROOT}/usr/include. (Once you add a user-space and a libc, you will configure your custom cross-gcc with --with-sysroot and it will look in ${SYSROOT}/usr/include. As a temporary work-around until you get that far, we fix it by passing -isystem=/usr/include).

Lo script `./headers.sh` copia in `sysroot/usr/include` gli header del progetto chiamando `make install headers` per ogni sottoprogetto.

### kernel design
Il kernel installa gli header in `sysroot/usr/include/kernel` e viene fatto il boot usando `GRUB` (viene creata l'immagine usando `xoriso` come nel Bare Bones tutorial).

### libc e libk
Ci sono due versioni della stessa libreria che si trovano nella cartella`libc`. Viene compilata la freestanding library, ossia `libk` che non contiene codice utente (ossia system calls) ed e' costruita con opzioni di compilazione differenti.

# analisi codice
> Dal manuale intel di **IA-64/32**:

L'architettura IA-32 supporta tre modalita:
* protected mode: stato nativo del processore e permette di emulare l'8086.
* real mode

> **Nota**: grub segue la specifica multiboot

> **Nota**: grub porta la cpu inprotected mode
https://wiki.osdev.org/Bootloader#What_does_a_boot_loader_do

https://www.gnu.org/software/grub/manual/multiboot/multiboot.html#Machine-state