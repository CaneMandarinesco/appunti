**Polling**: Meccanismo nel quale la cpu interpella lo stato di  dispositivo. A seguito della risposta la cpu decide se puo' accedere alla risorsa del dispositivo o se deve aspettare, facendo un'altra richiesta di poll.

**Interrupt**: Meccanismo nel quale la cpu puo' essere interrotta. I dispositivi possono notificare la cpu che una risorsa e' disponibile tramite segnali elettrici. La cpu deve interrompere l'esecuzione del codice per gestire la risorsa. La cpu riprende l'esecuzione da dove era stata interrotta.

**A Che serve**? Di solito l'interrupt viene usato dal dispositivo per notificare la cpu che ha finito di eseguire qualche task, di solito consiste nel prepare un buffer di memoria che la cpu puo trasferire in RAM. 

**Interrupt Controller**: raccoglie i segnali di interrupt inviati dai dispositivi e li instrada verso il pin della cpu.

**Interrupt Handler**: ogni interrupt ha un suo codice **IRQ** che lo identifica. Per ogni interrupt c'e' il suo handler (procedura, di solito in `C`) che la gestisce.

**Driver Linux**: un driver per un dispositivo definisce una tabella che associa ad ogni **IRQ** inviato dal dispositivo, la procedura relativa. Infatti, gli IRQ non sono completamente universali di dispositivo in dispositivo, dipende dai progettisti del dispositivo!

**Atomic Context**: gli interrupt sono eseguiti in contesti non bloccanti. Dunque nessun'altro segnale e' in grado di interrompere l'esecuzione di un interrupt.

**Top/Bottom Half**: non posso gestire tutto l'interrupt subito. Allora eseguo prima la **Top Half**, che gestisce la parte **time-critical**. Poi **Bottom Half** puo' gestire in un secondo momento il resto dell'interrupt.

Interrupt Context:

Interrupt Stack

... FINIRE!