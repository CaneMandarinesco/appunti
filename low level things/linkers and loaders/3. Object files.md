Compilatori e assembler creano file oggetto, mentre i linker li combinano in un'unico file oggetto. Il loader prende quest'ultimo e lo carica in memoria.

che informazioni contiene un object?
* *Header information*: size, nome del sorgente, data creazione
* *Object code*: dati generati dall'assembler/compialatore.
* *Relocation*: tutte le zone da aggiustare quando il linker opera.
* *Symbols*: simboli globali definiti e da importare negli altri moduli.
* *Debug Information*: source file, numero di riga, simboli locali, descrizioni delle strutture dati `C`.

Un file oggetto potrebbe essere: `linkable` e quindi usato come input da un link editor oppure `eseguibile`, capace di essere caricato in memoria come libreria insieme a un programma o come altro.

> [!note] linkable file
> contiene tanti simboli e informazioni di rilocazione, corredato con il codice eseguibile. 

> [!note] file eseguibile 
> Un file eseguibile contiene codice oggetto, allineato alla dimensione della pagina (cosi da poter essere mappato), ma non contiene simboli! A parte quelli che fanno riferimento a librerie dinamiche.

Nel `PDP-11`, un programma e' eseguibile e scritto secondo il **formato** `a.out` per `PDP-11`! con solo `16-bit` di indirizzamento, un programma e' lungo al piu `64KB`, dunque sono stati introdotti **due address space differenti**, da `64KB`:
* `I`: Instruction Space
* `D`: Data Space

Dunque ogni file oggetto per `PDP-11` ha:
* header
* text
* data

> **Nota**: con una `MMU` e segmentazione, posso indirizzare con `16-bit`, piu di `64kb` di memoria, per esempio.

Un linker dovrebbe marcare le parti di codice che sono read-only! Portano a vantaggi prestazionali!

L'header e' tipo cosi:
```c
int a_magic; // magic number
int a_text; // text segment size
int a_data; // initialized data size
int a_bss; // uninitialized data size

int a_syms; // symbol table size
int a_entry; // entry point
int a_trsize; // text relocation size
int a_drsize; // data relocation size
```

> [!note] magic number
> indica che tipo di esguibile e'.

dunque per eseguire un file devo:
* leggere l'header per capire le grandezze dei segmenti
* prima di allocare memoria, guarda se ci sono pagine che posso usare per leggere.
* crea un **segmento dati privato** per `.data, .bss`, **mappa** al processo e leggi di dati per `.data` dal file.
* crea stack con argomenti da riga di comando!
* imposta i registri e vai allo start address.

> **Nota**: posso mappare il file eseguibile alle pagine del processo!

> **Nota**: Per paginare l'eseguibile devo **allineare** il codice alla grandezza di ogni pagina

> **Nota**: il testo e' mappato come **read only**, i dati come **copy on write**!

Nella memoria del processo troviamo quindi in ordine:
* text (RO)
* data (COW, RW)
* bss: inizializzato sulla base di `.bss` (RW)
* heap (RW)
* area non mappata
* stack! (RW)

> **Nota**: con il formato `QMAGIC` l'header fa parte del testo e si trova in una sua pagina, ossia la `0` che non e' valida (non ha nessun tipo di informazione utile per l'esecuzione, una volta caricato il programma)!  dunque il programma eseguibile non si trova all'indirizzo `0x0` (e dunque possiamo associare l'uso di questo indirizzo ad errori gravi, come puntatori nulli).

### simboli e reallocazione: `a.out`
`a.out` e' fatto dunque cosi:
* `header`
* text
* data
* text reloc entry
* data reloc entry
* symbol table
* string table

> [!note] reloc entry
> Le relocation entry marcano dove bisogna modificare gli indirizzi, con la descrizione di cosa deve essere fatto.

Ogni entry ha: 
* **address**: offset rispetto al segmento
* **index**
* **pc rel flag**: se l'istruzione usa `PC relative addressing`
* **length**: lunghezza dei dati da relocare
* spare
* **extern flag**: il simbolo e' esterno?

Le entry della symbol table contengono:
* offset di 4 byte
* type di 1 byte
* spare di 1 byte 
* debug info di 2 byte
* valore di 4 byte

I gli identificatori per ogni simbolo si trovano nella string table, in modo da permettere **stringhe di lunghezza arbitraria**!