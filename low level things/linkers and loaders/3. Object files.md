Compilatori e assembler creano file oggetto, mentre i linker li combinano in un'unico file oggetto. Il loader prende quest'ultimo e lo carica in memoria.

che informazioni contiene un object?
* *Header information*: size, nome del sorgente, data creazione
* *Object code*: dati generati dall'assembler/compialatore.
* *Relocation*: tutte le zone da aggiustare quando il linker opera.
* *Symbols*: simboli globali definiti e da importare negli altri moduli.
* *Debug Information*: source file, numero di riga, simboli locali, descrizioni delle strutture dati `C`.

Un file oggetto potrebbe essere: `linkable` e quindi usato come input da un link editor oppure `eseguibile`, capace di essere caricato in memoria come libreria insieme a un programma o come altro.

> [!note] linkable file
> contiene tanti simboli e informazioni di rilocazione, corredato con il codice eseguibile. 

> [!note] file eseguibile 
> Un file eseguibile contiene codice oggetto, allineato alla dimensione della pagina (cosi da poter essere mappato), ma non contiene simboli! A parte quelli che fanno riferimento a librerie dinamiche.

Nel `PDP-11`, un programma e' eseguibile e scritto secondo il **formato** `a.out` per `PDP-11`! con solo `16-bit` di indirizzamento, un programma e' lungo al piu `64KB`, dunque sono stati introdotti **due address space differenti**, da `64KB`:
* `I`: Instruction Space
* `D`: Data Space

Dunque ogni file oggetto per `PDP-11` ha:
* header
* text
* data

> **Nota**: con una `MMU` e segmentazione, posso indirizzare con `16-bit`, piu di `64kb` di memoria, per esempio.

Un linker dovrebbe marcare le parti di codice che sono read-only! Portano a vantaggi prestazionali!

L'header e' tipo cosi:
```c
int a_magic; // magic number
int a_text; // text segment size
int a_data; // initialized data size
int a_bss; // uninitialized data size

int a_syms; // symbol table size
int a_entry; // entry point
int a_trsize; // text relocation size
int a_drsize; // data relocation size
```

> [!note] magic number
> indica che tipo di esguibile e'.

dunque per eseguire un file devo:
* leggere l'header per capire le grandezze dei segmenti
* prima di allocare memoria, guarda se ci sono pagine che posso usare per leggere.
* crea un **segmento dati privato** per `.data, .bss`, **mappa** al processo e leggi di dati per `.data` dal file.
* crea stack con argomenti da riga di comando!
* imposta i registri e vai allo start address.

> **Nota**: posso mappare il file eseguibile alle pagine del processo!

> **Nota**: Per paginare l'eseguibile devo **allineare** il codice alla grandezza di ogni pagina

> **Nota**: il testo e' mappato come **read only**, i dati come **copy on write**!

Nella memoria del processo troviamo quindi in ordine:
* text (RO)
* data (COW, RW)
* bss: inizializzato sulla base di `.bss` (RW)
* heap (RW)
* area non mappata
* stack! (RW)

> **Nota**: con il formato `QMAGIC` l'header fa parte del testo e si trova in una sua pagina, ossia la `0` che non e' valida (non ha nessun tipo di informazione utile per l'esecuzione, una volta caricato il programma)!  dunque il programma eseguibile non si trova all'indirizzo `0x0` (e dunque possiamo associare l'uso di questo indirizzo ad errori gravi, come puntatori nulli).

### simboli e reallocazione: `a.out`
`a.out` e' fatto dunque cosi:![[Pasted image 20251002180542.png]]

> [!note] reloc entry
> Le relocation entry marcano dove bisogna modificare gli indirizzi, con la descrizione di cosa deve essere fatto.

Ogni entry ha: 
* **address**: offset rispetto al segmento
* **index**
* **pc rel flag**: se l'istruzione usa `PC relative addressing`
* **length**: lunghezza dei dati da relocare
* spare
* **extern flag**: il simbolo e' esterno?

Le entry della symbol table contengono:
* offset di 4 byte
* type di 1 byte
* spare di 1 byte 
* debug info di 2 byte
* valore di 4 byte

I gli identificatori per ogni simbolo si trovano nella string table, in modo da permettere **stringhe di lunghezza arbitraria**!

## ELF

![[Pasted image 20251002180451.png]]


Ci sono 3 tipi di `elf`:
* **relocatable**: deve passare sotto al linker per eseguire e risolvere i simboli.
* **executable**: tutti i simboli sono risolti
* shared **object**: contiene codice corredato di informazioni di relocazione

### ELF relocatable
Un `ELF`  e' diviso in **segmenti**, ognuno contiene una o piu **sezioni**.

Le sezioni hanno un **tipo**:
* `PROGBITS`: contenuto del programma (codice, dati e debug info)
* `NOBITS`: come `progbits` ma usato per dati non inizializzati (come `BSS`)
* `SYMTAB` E `DYNSYM`: tabelle dei simboli
* `STRTAB`: contiene le stringhe a cui fanno riferimento le entry delle tabelle
* `REL/RELA`: informazione di relocazione.
* `DYNAMIC/HASH`: informazione per linking dinamico e la **hash table** la **runtime dei simboli**
* `SHN_ABS`: pesudo seszione che contiene simboli non rilocabili
* `SHN_COMMON`: pseudo sezione che contiene blocchi di dati non inizializzati

Le sezioni che mi aspetto di trovare sono:
* `.text`: di tipo `PROGBITS` con attributi `ALLOC+EXCINSTR`
* `.data`: di tipo `PROGBITS` e attrib `ALLOC+WRITE`
* `.rodata`: readonly data, `PROGBITS` e attributo `ALLOC`
* `.bss`: di tipo `NOBITS`, `ALLOC+WRITE`. Non occupa spazio nel file, server a descrivere are di memoria da allocare!
* `.rel.text, .rel.data, .rel.rodata` di tipo `REL/RELA`
* `.init` e `.fini`: come `.text` ma contiene codice da eseguire a startup e all'uscita. (Server per esempio a `c++` che ha strutture dati particolari da inizializzare e eliminare)
* `.symtab, .dynsym`: sono dei rispettivi tipi, e la `.dynsym` e' di tipo `ALLOC`, deve essere caricata a runtime.
* `.strtab`, `.dynstr`: di tipo `STRTAB`, la seconda con flag `ALLOC` contiene tutte le stringhe usate nelle tabelle dei simboli.
* `.got`: Global offset table
* `plt`: procedure linkage table
* `.debug`
* `.line`: src line number to object code location
* `.comment`: documentazione
* `.interp`: nome del programma da usare come interprete.

### ELF eseguibile
Contiene un `program header` che succede l'header elf, che descrive i segmenti che costituiscono il programma. Di solito ha un segmento read only per dati in sola lettura e uno read write per dati in scrittura. 

esempio di segmenti elf eseguibile:
![[Pasted image 20251002184632.png]]

Se sono presenti `.init` e `.fini` allora il linker fa in modo che il programma faccia chiamata alla sezione di codice eseguibile in  `.init` e quando termina chiama `.fini`.


## PE 
Formato usato da windows!!! 

